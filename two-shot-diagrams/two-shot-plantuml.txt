============================================================
TITLE: Project Management System
DESCRIPTION:
A project manager uses the project management system to manage a project. The project manager leads a team to execute the project within the project's start and end dates. Once a project is created in the project management system, a manager may initiate and later terminate the project due to its completion or for some other reason. As input, a project uses requirements. As output, a project produces a system (or part of a system). The requirements and system are work products: things that are created, used, updated, and elaborated on throughout a project. Every work product has a description, is of some percent complete throughout the effort, and may be validated. However, validation is dependent on the type of work product. For example, the requirements are validated with users in workshops, and the system is validated by being tested against the requirements. Furthermore, requirements may be published using various types of media, including on an intranet or in paper form; and systems may be deployed onto specific platforms.

PLANTUML CODE:
@startuml
class Project {
    projectId: String
    name: String
    startDate: Date
    endDate: Date
    status: Enum
}

class ProjectManager {
    managerId: String
    name: String
}

class TeamMember {
    memberId: String
    name: String
    role: String
}

abstract class WorkProduct {
    workProductId: String
    description: String
    percentComplete: Integer
    validationStatus: Enum
}

class Requirement extends WorkProduct {
    requirementId: String
    priority: Enum
}

class System extends WorkProduct {
    systemId: String
    version: String
}

class Publication {
    publicationId: String
    publicationDate: Date
    mediaType: Enum
}

class DeploymentPlatform {
    platformId: String
    name: String
    version: String
}

ProjectManager "1" -- "1..*" Project : manages
Project "1" -- "*" Requirement : uses
Project "1" -- "1" System : produces
Requirement "1" -- "0..*" Publication : is published in
System "1" -- "1..*" DeploymentPlatform : is deployed on
Project "1" -- "1..*" TeamMember : has

@enduml

============================================================
TITLE: Hollywood Approach
DESCRIPTION:
We are interested in building a software application to manage filmed scenes for realizing a movie, by following the so-called “Hollywood Approach”. Every scene is identified by a code (a string) and it is described by a text in natural language. Every scene is filmed from different positions (at least one), each of this is called a setup. Every setup is characterized by a code (a string) and a text in natural language where the photographic parameters are noted (e.g., aperture, exposure, focal length, filters, etc.). Note that a setup is related to a single scene. For every setup, several takes may be filmed (at least one). Every take is characterized by a (positive) natural number, a real number representing the number of meters of film that have been used for shooting the take, and the code (a string) of the reel where the film is stored. Note that a take is associated to a single setup. Scenes are divided into internals that are filmed in a theater, and externals that are filmed in a location and can either be “day scene” or “night scene”. Locations are characterized by a code (a string) and the address of the location, and a text describing them in natural language.

PLANTUML CODE:
@startuml
class Scene {
    code: String
    description: String
}

class Setup {
    code: String
    photographicParameters: String
}

class Take {
    number: Integer
    filmLength: Real
    reelCode: String
}

class InternalScene extends Scene {
}

class ExternalScene extends Scene {
    timeOfDay: enum {Day, Night}
}

class Location {
    code: String
    address: String
    description: String
}

Scene "1" -- "1..*" Setup : has >
Setup "1" -- "1..*" Take : has >
Setup "1" -- "1" Scene : belongs to >
ExternalScene "1" -- "1" Location : has >

@enduml

============================================================
TITLE: Word Processor
DESCRIPTION:
A user can open a new or existing document. Text is entered through a keyboard. A document is made up of several pages and each page is made up of a header, body and footer. Date, time and page number may be added to header or footer. Document body is made up of sentences, which are themselves made up of words and punctuation characters. Words are made up of letters, digits and/or special characters. Pictures and tables may be inserted into the document body. Tables are made up of rows and columns and every cell in a table can contain both text and pictures. Users can save or print documents.

PLANTUML CODE:
@startuml
class Document {
    documentId: UUID
    title: String
    author: String
    dateCreated: Date
    dateModified: Date
    open()
    save()
    print()
}

class Page {
    pageNumber: Integer
}

class Header {
}

class Footer {
}

class Body {
}

class Sentence {
}

class Word {
    text: String
}

abstract class Character {
    value: Char
}

class Letter extends Character {
}

class Digit extends Character {
}

class SpecialCharacter extends Character {
}

class Punctuation {
    symbol: Char
}

class Picture {
    pictureId: UUID
    filePath: String
    altText: String
}

class Table {
}

class Row {
}

class Column {
}

class Cell {
}

class Date {
    dateValue: Date
}

class Time {
    timeValue: Time
}

class PageNumber {
    number: Integer
}

Document "1" o-- "1..*" Page : composes
Page "1" *-- "1" Header : composes
Page "1" *-- "1" Body : composes
Page "1" *-- "1" Footer : composes
Body "1" o-- "0..*" Sentence : composes
Body "1" -- "0..*" Picture : contains
Body "1" -- "0..*" Table : contains
Sentence "1" o-- "1..*" Word : composes
Sentence "1" o-- "0..*" Punctuation : composes
Word "1" o-- "1..*" Character : composes
Table "1" o-- "1..*" Row : composes
Row "1" o-- "1..*" Column : composes
Column "1" -- "1" Cell : has

Header "1" -- "0..1" Date : contains
Header "1" -- "0..1" Time : contains
Header "1" -- "0..1" PageNumber : contains
Footer "1" -- "0..1" Date : contains
Footer "1" -- "0..1" Time : contains
Footer "1" -- "0..1" PageNumber : contains

Cell "1" -- "0..1" String : contains
Cell "1" -- "0..1" Picture : contains

@enduml

============================================================
TITLE: Patient Record and Scheduling System
DESCRIPTION:
A patient record and scheduling system in a doctor’s office is used by the receptionists, nurses, and doctors. The receptionists use the system to enter new patient information when first-time patients visit the doctor. They also schedule all appointments. The nurses use the system to keep track of the results of each visit including diagnosis and medications. For each visit, free form text fields are used captures information on diagnosis and treatment. Multiple medications may be prescribed during each visit. The nurses can also access the information to print out a history of patient visits. The doctors primarily use the system to view patient history. The doctors may enter some patient treatment information and prescriptions occasionally, but most frequently they let the nurses enter this information. -- Each patient is assigned to a family. The head of family is responsible for the person with the primary medical coverage. Information about doctors is maintained since a family has a primary care physician, but different doctors may be the ones seeing the patient during the visit.

PLANTUML CODE:
@startuml
class Patient {
    patientId: Integer
    firstName: String
    lastName: String
    dateOfBirth: Date
    gender: String
    address: String
    phone: String
    insuranceProvider: String
    insurancePolicyNumber: String
}

class Family {
    familyId: Integer
    familyName: String
    headOfHousehold: Integer
}

class Appointment {
    appointmentId: Integer
    appointmentDate: DateTime
    reasonForVisit: String
    notes: String
}

class Visit {
    visitId: Integer
    visitDate: DateTime
    diagnosis: String
    treatment: String
}

class Medication {
    medicationId: Integer
    medicationName: String
    dosage: String
    frequency: String
    route: String
    notes: String
}

class Doctor {
    doctorId: Integer
    firstName: String
    lastName: String
    specialty: String
    employeeId: String
}

class Receptionist {
    receptionistId: Integer
    firstName: String
    lastName: String
    employeeId: String
}

class Nurse {
    nurseId: Integer
    firstName: String
    lastName: String
    employeeId: String
}

Patient "1..*" -- "1" Family
Family "1" -- "0..*" Doctor
Patient "1" -- "1..*" Appointment
Appointment "1" -- "0..1" Visit
Visit "1" -- "1..*" Medication
Visit "1" -- "1..*" Nurse
Visit "0..*" -- "0..1" Doctor
Appointment "1..*" -- "1" Receptionist

@enduml

============================================================
TITLE: Movie-Shop
DESCRIPTION:
♣ Design a system for a movie-shop, in order to handle ordering of movies and browsing of the catalogue of the store, and user subscriptions with rechargeable cards. ♣ Only subscribers are allowed hiring movies with their own card. ♣ Credit is updated on the card during rent operations. ♣ Both users and subscribers can buy a movie and their data are saved in the related order. ♣ When a movie is not available it is ordered .

PLANTUML CODE:
@startuml
class MovieShop {
    shopId: UUID
    name: String
    address: String
}

class Movie {
    movieId: UUID
    title: String
    genre: String
    price: Double
    availability: Integer
    orderMovie()
}

class User {
    userId: UUID
    name: String
    address: String
    email: String
}

class Subscriber extends User {
    subscriptionId: UUID
    cardId: UUID
    credit: Double
    rechargeCard(amount: Double)
    rentMovie(movie: Movie)
}

enum Status {
    Placed
    Shipped
    Delivered
}

class Order {
    orderId: UUID
    orderDate: Date
    quantity: Integer
    totalAmount: Double
    status: Status
}

class Rental {
    rentalId: UUID
    rentalDate: Date
    returnDate: Date
    dueDate: Date
}

MovieShop "1" -- "*" Movie : has >
MovieShop "1" -- "*" User : has >

Movie "*" -- "1" MovieShop : belongs to >
Movie "1" -- "*" Order : part of >

User "*" -- "1" MovieShop : associated with >
User "1" -- "*" Order : places >
User "1" -- "1" Subscriber : can be >

Subscriber "1" -- "*" Rental : has >

Order "*" -- "1" User : placed by >
Order "*" -- "1" Movie : for >

Rental "*" -- "1" Subscriber : made by >
Rental "*" -- "1" Movie : for >

@enduml

============================================================
TITLE: Flights
DESCRIPTION:
We want to model a system for management of flights and pilots. An airline operates flights. Each airline has an ID. Each flight has an ID a departure airport and an arrival airport: an airport as a unique identifier. Each flight has a pilot and a co-pilot, and it uses an aircraft of a certain type; a flight has also a departure time and an arrival time. An airline owns a set of aircrafts of different types. An aircraft can be in a working state or it can be under repair. In a particular moment an aircraft can be landed or airborne. A company has a set of pilots: each pilot has an experience level: 1 is minimum, 3 is maximum. A type of aeroplane may need a particular number of pilots, with a different role (e.g.: captain, co-pilot, navigator): there must be at least one captain and one co-pilot, and a captain must have a level 3.

PLANTUML CODE:
@startuml
class Airline {
    airlineId: String
}

class Aircraft {
    aircraftId: String
    type: String
    status: AircraftStatus
    locationStatus: LocationStatus
}

enum AircraftStatus {
    WORKING
    UNDER_REPAIR
}

enum LocationStatus {
    LANDED
    AIRBORNE
}

class Flight {
    flightId: String
    departureTime: Date
    arrivalTime: Date
}

class Airport {
    airportId: String
    name: String
}

class Pilot {
    pilotId: String
    experienceLevel: ExperienceLevel
}

enum ExperienceLevel {
    ONE
    TWO
    THREE
}

class Company {
    companyId: String
}

class AircraftTypePilotsNeeded {
    role: String
    minimumExperienceLevel: ExperienceLevel
    pilotQuantity: Integer
}

Airline "1" -- "1..*" Aircraft : owns
Airline "1" -- "0..*" Flight : operates

Aircraft "1" -- "1" Airline : owned by
Aircraft "1" -- "0..*" Flight : used by

Flight "1" -- "1" Airline : operated by
Flight "1" -- "1" Airport : departs from
Flight "1" -- "1" Airport : arrives at
Flight "1" -- "1" Pilot : captain
Flight "1" -- "1" Pilot : coPilot
Flight "1" -- "1" Aircraft : uses

Airport "1" -- "0..*" Flight : departure
Airport "1" -- "0..*" Flight : arrival

Pilot "1" -- "1" Company : belongs to
Company "1" -- "0..*" Pilot : employs

AircraftTypePilotsNeeded "*" -- "1" Aircraft : Is specified for

@enduml

============================================================
TITLE: Veterinary Clinic
DESCRIPTION:
The owner of a veterinary clinic wants to create a database to store information about all veterinary services performed. After some research he came up with the following requirements: ● For each admitted animal, its name, breed (if any) and owner must be stored. Each animal should be given an unique numeric identifier. ● For each owner, its name, address and phone number should be stored. An unique numeric identifier should also be generated for each one of them. ● An animal might be owner-less. This happens frequently as the clinic often rescues abandoned dogs from the streets in order to treat them and get them new owners. ● It should be possible to store information about a specific breed even if no animals of that breed have been treated at the clinic. ● Each appointement always has a responsible physician. All appointements start at a certain date and time; and are attended by an animal (and of course its owner). ● For each physician, his name, address and phone number should be stored. An unique numeric identifier should also be generated for each one of them. ● In an appointement, several medical conditions might be detected. Each condition has a common name and a scientific name. No two conditions have the same scientific name. ● It should be possible to store information about the most common conditions for each different breed in the database.

PLANTUML CODE:
@startuml

class Animal {
    animalId: Integer
    name: String
    breed: String
}

class Owner {
    ownerId: Integer
    name: String
    address: String
    phoneNumber: String
}

class Breed {
    breedName: String
}

class Appointment {
    appointmentId: Integer
    startDateTime: DateTime
}

class Physician {
    physicianId: Integer
    name: String
    address: String
    phoneNumber: String
}

class Condition {
    commonName: String
    scientificName: String
}

class AppointmentCondition {
    notes: String
}

class BreedCondition {
}

Animal "0..1" -- "0..*" Owner : owns
Animal "1..*" -- "*" Appointment : has
Appointment "*" -- "1" Physician : is attended by
Appointment "*" -- "*" Condition : detects
Appointment "*" -- "1" AppointmentCondition : details
Condition "*" -- "1" AppointmentCondition : describes
Animal "0..1" -- "1..*" Breed : belongs to
Breed "*" -- "*" Condition : associates with
Breed "*" -- "1" BreedCondition : relates
Condition "*" -- "1" BreedCondition : links


@enduml

============================================================
TITLE: Bank System
DESCRIPTION:
A bank system contains data on customers (identified by name and address) and their accounts. Each account has a balance and there are 2 type of accounts: one for savings which offers an interest rate, the other for investments, used to buy stocks. Stocks are bought at a certain quantity for a certain price (ticker) and the bank applies commission on stock orders.

PLANTUML CODE:
@startuml
class Customer {
    customerId : Integer
    name : String
    address : String
    contactInfo : String
    + getCustomerId() : Integer
    + setName(name : String)
    + setAddress(address : String)
}

abstract class Account {
    accountId : Integer
    balance : Double
    accountType : String
    + deposit(amount : Double)
    + withdraw(amount : Double)
    + getBalance() : Double
    + getAccountId() : Integer
}

class SavingsAccount extends Account {
    interestRate : Double
    + calculateInterest() : Double
    + setInterestRate(interestRate : Double)
    + getInterestRate() : Double
}

class InvestmentAccount extends Account {
    + buyStock(stock : Stock, quantity : Integer)
    + sellStock(stock : Stock, quantity : Integer)
}

class Stock {
    ticker : String
    companyName : String
    currentPrice : Double
    + getTicker() : String
    + setcurrentPrice(currentPrice : Double)
}

class StockOrder {
    orderId : Integer
    quantity : Integer
    price : Double
    commission : Double
    orderDate : Date
    orderType : String
    + calculateTotalCost() : Double
    + getOrderDate() : Date
}

Customer "1" -- "*" Account : owns
Account "*" -- "1" Customer : owned by

InvestmentAccount "1" -- "*" StockOrder : places
StockOrder "*" -- "1" InvestmentAccount : placed by

StockOrder "*" -- "1" Stock : is for
Stock "*" -- "*" StockOrder : traded in
@enduml

