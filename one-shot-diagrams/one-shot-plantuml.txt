============================================================
TITLE: Project Management System
DESCRIPTION:
A project manager uses the project management system to manage a project. The project manager leads a team to execute the project within the project's start and end dates. Once a project is created in the project management system, a manager may initiate and later terminate the project due to its completion or for some other reason. As input, a project uses requirements. As output, a project produces a system (or part of a system). The requirements and system are work products: things that are created, used, updated, and elaborated on throughout a project. Every work product has a description, is of some percent complete throughout the effort, and may be validated. However, validation is dependent on the type of work product. For example, the requirements are validated with users in workshops, and the system is validated by being tested against the requirements. Furthermore, requirements may be published using various types of media, including on an intranet or in paper form; and systems may be deployed onto specific platforms.

PLANTUML CODE:
@startuml
class ProjectManager {
    projectManagerId: Integer
    name: String
    email: String
}

class Project {
    projectId: Integer
    name: String
    startDate: Date
    endDate: Date
    status: Enum
    initiate(): Void
    terminate(): Void
}

class TeamMember {
    teamMemberId: Integer
    name: String
    role: String
}

abstract class WorkProduct {
    workProductId: Integer
    description: String
    percentComplete: Double
    validationStatus: Boolean
    validate(): Boolean
}

class Requirement extends WorkProduct {
    publicationMedium: String
    validate(): Boolean
}

class System extends WorkProduct {
    deploymentPlatform: String
    validate(): Boolean
}

ProjectManager "1" -- "*" Project : manages
Project "1" -- "*" TeamMember : has
Project "1" -- "*" Requirement : uses
Project "1" -- "1" System : produces
TeamMember "*" -- "1" Project : works on
Requirement "*" -- "1" Project : is used by
System "1" -- "1" Project : is produced by

@enduml

============================================================
TITLE: Hollywood Approach
DESCRIPTION:
We are interested in building a software application to manage filmed scenes for realizing a movie, by following the so-called “Hollywood Approach”. Every scene is identified by a code (a string) and it is described by a text in natural language. Every scene is filmed from different positions (at least one), each of this is called a setup. Every setup is characterized by a code (a string) and a text in natural language where the photographic parameters are noted (e.g., aperture, exposure, focal length, filters, etc.). Note that a setup is related to a single scene. For every setup, several takes may be filmed (at least one). Every take is characterized by a (positive) natural number, a real number representing the number of meters of film that have been used for shooting the take, and the code (a string) of the reel where the film is stored. Note that a take is associated to a single setup. Scenes are divided into internals that are filmed in a theater, and externals that are filmed in a location and can either be “day scene” or “night scene”. Locations are characterized by a code (a string) and the address of the location, and a text describing them in natural language.

PLANTUML CODE:
@startuml
abstract class Scene {
    sceneCode : String
    description : String
}

class InternalScene extends Scene {
}

enum TimeOfDay {
    Day
    Night
}

class ExternalScene extends Scene {
    timeOfDay : TimeOfDay
}

class Setup {
    setupCode : String
    photographicNotes : String
}

class Take {
    takeNumber : Integer
    filmLengthMeters : Real
    reelCode : String
}

class Location {
    locationCode : String
    address : String
    description : String
}

Scene "1" -- "*" Setup : has
Setup "1" -- "*" Take : has
ExternalScene "1" -- "1" Location : filmed at
@enduml

============================================================
TITLE: Word Processor
DESCRIPTION:
A user can open a new or existing document. Text is entered through a keyboard. A document is made up of several pages and each page is made up of a header, body and footer. Date, time and page number may be added to header or footer. Document body is made up of sentences, which are themselves made up of words and punctuation characters. Words are made up of letters, digits and/or special characters. Pictures and tables may be inserted into the document body. Tables are made up of rows and columns and every cell in a table can contain both text and pictures. Users can save or print documents.

PLANTUML CODE:
@startuml
class User {
    userId: Integer
    openDocument(document: Document): void
    saveDocument(document: Document): void
    printDocument(document: Document): void
}

class Document {
    documentId: Integer
    title: String
    filePath: String
    create(): void
    save(): void
    print(): void
}

class Page {
    pageNumber: Integer
}

class Header {
    content: String
    addDateTime(): void
    addPageNumber(page: Page): void
}

class Footer {
    content: String
    addDateTime(): void
    addPageNumber(page: Page): void
}

class Body {
    content: String
}

class Sentence {
    text: String
}

class Word {
    text: String
}

class Punctuation {
    character: Char
}

abstract class TextElement {
    text: String
}

abstract class MediaElement

class Picture {
    imagePath: String
    altText: String
}

class Table {
    numRows: Integer
    numColumns: Integer
}

class Row {
}

class Cell {
    content: String
}

User -- Document : opens, saves, prints
Document *-- "1..*" Page : is composed of
Page o-- "1" Header : has
Page o-- "1" Body : has
Page o-- "1" Footer : has
Body *-- "0..*" Sentence : contains
Sentence *-- "1..*" Word : is composed of
Sentence *-- "0..*" Punctuation : is composed of
Word --|> TextElement
Punctuation --|> TextElement
Picture --|> MediaElement
Table --|> MediaElement
Table *-- "1..*" Row : is composed of
Row *-- "1..*" Cell : is composed of
Cell o-- "0..*" TextElement : contains
Cell o-- "0..*" Picture : contains
Picture -- "1" Body : belongs to
Table -- "1" Body : belongs to

@enduml

============================================================
TITLE: Patient Record and Scheduling System
DESCRIPTION:
A patient record and scheduling system in a doctor’s office is used by the receptionists, nurses, and doctors. The receptionists use the system to enter new patient information when first-time patients visit the doctor. They also schedule all appointments. The nurses use the system to keep track of the results of each visit including diagnosis and medications. For each visit, free form text fields are used captures information on diagnosis and treatment. Multiple medications may be prescribed during each visit. The nurses can also access the information to print out a history of patient visits. The doctors primarily use the system to view patient history. The doctors may enter some patient treatment information and prescriptions occasionally, but most frequently they let the nurses enter this information. -- Each patient is assigned to a family. The head of family is responsible for the person with the primary medical coverage. Information about doctors is maintained since a family has a primary care physician, but different doctors may be the ones seeing the patient during the visit.

PLANTUML CODE:
@startuml
class Patient {
    patientId: Integer
    firstName: String
    lastName: String
    dateOfBirth: Date
    address: String
    phone: String
    insuranceProvider: String
    insurancePolicyNumber: String
}

class Family {
    familyId: Integer
    familyName: String
    addMember(patient: Patient): Void
    removeMember(patient: Patient): Void
}

class Doctor {
    doctorId: Integer
    firstName: String
    lastName: String
    specialization: String
}

class Visit {
    visitId: Integer
    visitDate: Date
    chiefComplaint: String
    diagnosis: String
    treatment: String
    addMedication(medication: Medication): Void
    removeMedication(medication: Medication): Void
}

class Medication {
    medicationId: Integer
    name: String
    dosage: String
    route: String
    frequency: String
}

class Appointment {
    appointmentId: Integer
    appointmentDate: DateTime
    reason: String
    status: String
}

Patient "1..1" --o "1..*" Family : member
Family "1" -- "0..1" Patient : familyHead
Appointment "1" -- "0..*" Patient : patient
Appointment "1" -- "0..*" Doctor : doctor
Visit "1" -- "0..*" Patient : patient
Visit "1" -- "0..*" Doctor : doctor
Visit "1" *-- "0..*" Medication : medication
Family "1" -- "0..*" Doctor : primaryCarePhysician

@enduml

============================================================
TITLE: Movie-Shop
DESCRIPTION:
♣ Design a system for a movie-shop, in order to handle ordering of movies and browsing of the catalogue of the store, and user subscriptions with rechargeable cards. ♣ Only subscribers are allowed hiring movies with their own card. ♣ Credit is updated on the card during rent operations. ♣ Both users and subscribers can buy a movie and their data are saved in the related order. ♣ When a movie is not available it is ordered .

PLANTUML CODE:
@startuml
class MovieShop {
    shopId: UUID
    name: String
    address: String
    addMovie(movie: Movie): void
    removeMovie(movie: Movie): void
    browseCatalog(query: String): List<Movie>
}

class Movie {
    movieId: UUID
    title: String
    director: String
    genre: String
    releaseYear: Integer
    availableCopies: Integer
    rentalPrice: Double
    purchasePrice: Double
    rentMovie(): boolean
    buyMovie(): void
    orderMovie(): void
}

class User {
    userId: UUID
    name: String
    address: String
    email: String
    phoneNumber: String
    buyMovie(movie: Movie): Order
    browseCatalog(): List<Movie>
}

class Subscriber extends User {
    subscriptionId: UUID
    cardNumber: String
    credit: Double
    rentMovie(movie: Movie): Rental
    rechargeCard(amount: Double): void
    getCredit(): Double
}

class Order {
    orderId: UUID
    orderDate: LocalDate
    totalAmount: Double
    calculateTotal(): Double
}

class Rental {
    rentalId: UUID
    rentalDate: LocalDate
    dueDate: LocalDate
    returnDate: LocalDate
    rentalFee: Double
    calculateLateFee(): Double
    returnMovie(): void
}

class RechargeableCard {
    cardNumber: String
    credit: Double
}

MovieShop "*" -- "*" Movie : contains
User "*" -- "*" Order : places
Order "*" -- "*" Movie : contains
Subscriber "*" -- "*" Rental : has
Rental "1" -- "1" Movie : involves
Subscriber "1" -- "1" RechargeableCard : uses
RechargeableCard "*" -- "*" Rental : used in
Movie "*" -- "*" Order : added to
Movie "*" -- "*" Rental : rented in
Movie "isOrderedBy" -- "1" MovieShop: orders
@enduml

============================================================
TITLE: Flights
DESCRIPTION:
We want to model a system for management of flights and pilots. An airline operates flights. Each airline has an ID. Each flight has an ID a departure airport and an arrival airport: an airport as a unique identifier. Each flight has a pilot and a co-pilot, and it uses an aircraft of a certain type; a flight has also a departure time and an arrival time. An airline owns a set of aircrafts of different types. An aircraft can be in a working state or it can be under repair. In a particular moment an aircraft can be landed or airborne. A company has a set of pilots: each pilot has an experience level: 1 is minimum, 3 is maximum. A type of aeroplane may need a particular number of pilots, with a different role (e.g.: captain, co-pilot, navigator): there must be at least one captain and one co-pilot, and a captain must have a level 3.

PLANTUML CODE:
@startuml
class Airline {
    airlineId: String
}

class Flight {
    flightId: String
    departureTime: DateTime
    arrivalTime: DateTime
}

class Airport {
    airportId: String
}

enum AircraftStatus {
    Working
    UnderRepair
}

enum AircraftLocationStatus {
    Landed
    Airborne
}

class Aircraft {
    aircraftId: String
    status: AircraftStatus
    locationStatus: AircraftLocationStatus
}

class AircraftType {
    typeName: String
    requiredPilots: Integer
}

enum PilotExperienceLevel {
    "1 (Minimum)"
    "2"
    "3 (Maximum)"
}

class Pilot {
    pilotId: String
    experienceLevel: PilotExperienceLevel
}

class PilotRequirement {
    role: String
    experienceLevelRequired: PilotExperienceLevel
}

Airline "1" -- "1..*" Flight : operates
Airline "1" -- "1..*" Aircraft : owns
Airline "1" -- "1..*" Pilot : employs

Flight "1" -- "1" Airport : DepartureAirport
Flight "1" -- "1" Airport : ArrivalAirport
Flight "1" -- "1" Pilot : Captain
Flight "1" -- "1" Pilot : CoPilot
Flight "1" -- "1" Aircraft : Aircraft
Flight "1" -- "1" Airline : Airline

Airport "1" -- "0..*" Flight : DepartureFlights
Airport "1" -- "0..*" Flight : ArrivalFlights

Aircraft "1" -- "1" Airline : Airline
Aircraft "1" -- "1" AircraftType : AircraftType
Aircraft "1" -- "0..*" Flight : Flights

AircraftType "1" -- "0..*" Aircraft : Aircraft
AircraftType "1" -- "1..*" PilotRequirement : PilotRequirements

Pilot "1" -- "1" Airline : Airline
Pilot "1" -- "0..*" Flight : CaptainFlights
Pilot "1" -- "0..*" Flight : CoPilotFlights
Pilot "1" -- "0..*" PilotRequirement : PilotRequirements

PilotRequirement "1" -- "1" AircraftType : AircraftType
PilotRequirement "1" -- "0..*" Pilot : Pilot

@enduml

============================================================
TITLE: Bank System
DESCRIPTION:
A bank system contains data on customers (identified by name and address) and their accounts. Each account has a balance and there are 2 type of accounts: one for savings which offers an interest rate, the other for investments, used to buy stocks. Stocks are bought at a certain quantity for a certain price (ticker) and the bank applies commission on stock orders.

PLANTUML CODE:
@startuml
class Customer {
    customerId: Integer
    name: String
    address: String
}

abstract class Account {
    accountId: Integer
    balance: Double
}

class SavingsAccount extends Account {
    interestRate: Double
}

class InvestmentAccount extends Account {
}

class Stock {
    ticker: String
}

class StockOrder {
    orderId: Integer
    quantity: Integer
    price: Double
}

class Commission {
    commissionId: Integer
    commissionRate: Double
}

Customer "1" -- "1..*" Account : owns >
Account "1" -- "1" Customer : ownedBy >

InvestmentAccount "1" -- "1..*" StockOrder : places >
StockOrder "1" -- "1" InvestmentAccount : placedBy >

StockOrder "1" -- "1" Stock : orders >
Stock "1..*" -- "1" StockOrder : orderedBy >

StockOrder "1" -- "1" Commission : applies >
Commission "1" -- "1" StockOrder : appliedTo >

@enduml

============================================================
TITLE: Veterinary Clinic
DESCRIPTION:
The owner of a veterinary clinic wants to create a database to store information about all veterinary services performed. After some research he came up with the following requirements: ● For each admitted animal, its name, breed (if any) and owner must be stored. Each animal should be given an unique numeric identifier. ● For each owner, its name, address and phone number should be stored. An unique numeric identifier should also be generated for each one of them. ● An animal might be owner-less. This happens frequently as the clinic often rescues abandoned dogs from the streets in order to treat them and get them new owners. ● It should be possible to store information about a specific breed even if no animals of that breed have been treated at the clinic. ● Each appointement always has a responsible physician. All appointements start at a certain date and time; and are attended by an animal (and of course its owner). ● For each physician, his name, address and phone number should be stored. An unique numeric identifier should also be generated for each one of them. ● In an appointement, several medical conditions might be detected. Each condition has a common name and a scientific name. No two conditions have the same scientific name. ● It should be possible to store information about the most common conditions for each different breed in the database.

PLANTUML CODE:
@startuml
class Animal {
    animalId: Integer
    name: String
    breed: String
}

class Owner {
    ownerId: Integer
    name: String
    address: String
    phoneNumber: String
}

class Breed {
    breedName: String
}

class Physician {
    physicianId: Integer
    name: String
    address: String
    phoneNumber: String
}

class Appointment {
    appointmentId: Integer
    dateTime: DateTime
}

class MedicalCondition {
    scientificName: String
    commonName: String
}

class CommonCondition {
}

Animal "0..1" -- "1..*" Owner : owns
Animal "0..1" -- "0..*" Breed : isA
Physician "1" -- "1..*" Appointment : handles
Animal "1" -- "0..*" Appointment : has
Appointment "1..*" -- "0..*" MedicalCondition : detects
Breed "1" -- "0..*" CommonCondition : hasCommon
MedicalCondition "1" -- "0..*" CommonCondition : isCommon

@enduml

