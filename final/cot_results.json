[
  {
    "title": "Project Management System",
    "description": "A project manager uses the project management system to manage a project. The project manager leads a team to execute the project within the project's start and end dates. Once a project is created in the project management system, a manager may initiate and later terminate the project due to its completion or for some other reason. As input, a project uses requirements. As output, a project produces a system (or part of a system). The requirements and system are work products: things that are created, used, updated, and elaborated on throughout a project. Every work product has a description, is of some percent complete throughout the effort, and may be validated. However, validation is dependent on the type of work product. For example, the requirements are validated with users in workshops, and the system is validated by being tested against the requirements. Furthermore, requirements may be published using various types of media, including on an intranet or in paper form; and systems may be deployed onto specific platforms.",
    "textual_uml": "```\nCLASS: Project Manager\nDescription: This entity represents the individual responsible for overseeing and managing the project, making it a key role in the project management system.\nATTRIBUTES:\n- name: String\n- email: String\n- phone: String\n- projects: List<Project>\nMETHODS:\n- createProject(): Project\n- initiateProject(project: Project): void\n- terminateProject(project: Project): void\n- assignTeam(team: Team): void\n\nRELATIONSHIPS:\n- Project Manager manages Project 1..*\n\nCLASS: Project\nDescription: The central entity that encompasses the entire effort, including its start and end dates, and is subject to initiation and termination.\nATTRIBUTES:\n- startDate: Date\n- endDate: Date\n- status: String\n- requirements: List<Requirements>\n- system: System\n- team: Team\nMETHODS:\n- addRequirement(requirement: Requirements): void\n- removeRequirement(requirement: Requirements): void\n- updateStatus(newStatus: String): void\n- produceSystem(): System\n\nRELATIONSHIPS:\n- Project contains Team 1..1\n- Project uses Requirements 0..*\n- Project produces System 0..1\n\nCLASS: Team\nDescription: Refers to the group of individuals working under the project manager to execute the project, highlighting the collaborative aspect of project management.\nATTRIBUTES:\n- members: List<String>\n- project: Project\nMETHODS:\n- addMember(member: String): void\n- removeMember(member: String): void\n- getTeamMembers(): List<String>\n\nRELATIONSHIPS:\n- Team is part of Project 1..1\n\nCLASS: Requirements\nDescription: These are the inputs for the project that define what needs to be accomplished, making them a critical component of the project lifecycle.\nATTRIBUTES:\n- description: String\n- percentComplete: Double\n- validationStatus: String\n- media: List<Media>\nMETHODS:\n- validate(): void\n- updateDescription(newDescription: String): void\n- updatePercentComplete(newPercent: Double): void\n- publish(media: Media): void\n\nRELATIONSHIPS:\n- Requirements is a Work Product 1..1\n- Requirements published via Media 0..*\n\nCLASS: System\nDescription: Represents the output of the project, which is the end product or part of a product that is developed based on the requirements.\nATTRIBUTES:\n- description: String\n- percentComplete: Double\n- validationStatus: String\n- platform: Platform\nMETHODS:\n- validate(): void\n- updateDescription(newDescription: String): void\n- updatePercentComplete(newPercent: Double): void\n- deploy(platform: Platform): void\n\nRELATIONSHIPS:\n- System is a Work Product 1..1\n- System deployed on Platform 0..*\n\nCLASS: Work Product\nDescription: A general term that encompasses both requirements and systems, indicating items that are created, used, updated, and validated throughout the project.\nATTRIBUTES:\n- description: String\n- percentComplete: Double\n- validationStatus: String\nMETHODS:\n- updateDescription(newDescription: String): void\n- updatePercentComplete(newPercent: Double): void\n- validate(): void\n\nRELATIONSHIPS:\n- Work Product has Description 1..1\n- Work Product has Percent Complete 1..1\n- Work Product undergoes Validation 0..*\n\nCLASS: Description\nDescription: This refers to the textual or documented explanation of a work product, which is essential for understanding its purpose and scope.\nATTRIBUTES:\n- text: String\nMETHODS:\n- getText(): String\n- setText(newText: String): void\n\nRELATIONSHIPS:\n- Description is associated with Work Product 1..1\n\nCLASS: Percent Complete\nDescription: Represents the progress metric for work products, indicating how much of the work has been completed at any given time.\nATTRIBUTES:\n- value: Double\nMETHODS:\n- getValue(): Double\n- setValue(newValue: Double): void\n\nRELATIONSHIPS:\n- Percent Complete is associated with Work Product 1..1\n\nCLASS: Validation\nDescription: This entity represents the process of confirming that a work product meets its requirements, which is crucial for ensuring quality.\nATTRIBUTES:\n- status: String\n- date: Date\n- validatedBy: String\nMETHODS:\n- performValidation(): void\n- getValidationStatus(): String\n\nRELATIONSHIPS:\n- Validation is associated with Work Product 0..*\n\nCLASS: Media\nDescription: Refers to the various forms through which requirements can be published, such as intranet or paper, highlighting the communication aspect of project management.\nATTRIBUTES:\n- type: String\n- content: String\nMETHODS:\n- publish(): void\n- getContent(): String\n\nRELATIONSHIPS:\n- Media is used by Requirements 0..*\n\nCLASS: Platform\nDescription: Represents the specific environments onto which systems can be deployed, indicating the technical aspect of the project outputs.\nATTRIBUTES:\n- name: String\n- version: String\nMETHODS:\n- getDetails(): String\n- isCompatible(system: System): Boolean\n\nRELATIONSHIPS:\n- Platform hosts System 0..*\n```"
  },
  {
    "title": "Hollywood Approach",
    "description": "We are interested in building a software application to manage filmed scenes for realizing a movie, by following the so-called “Hollywood Approach”. Every scene is identified by a code (a string) and it is described by a text in natural language. Every scene is filmed from different positions (at least one), each of this is called a setup. Every setup is characterized by a code (a string) and a text in natural language where the photographic parameters are noted (e.g., aperture, exposure, focal length, filters, etc.). Note that a setup is related to a single scene. For every setup, several takes may be filmed (at least one). Every take is characterized by a (positive) natural number, a real number representing the number of meters of film that have been used for shooting the take, and the code (a string) of the reel where the film is stored. Note that a take is associated to a single setup. Scenes are divided into internals that are filmed in a theater, and externals that are filmed in a location and can either be “day scene” or “night scene”. Locations are characterized by a code (a string) and the address of the location, and a text describing them in natural language.",
    "textual_uml": "```\nCLASS: Scene\nDescription: Represents a filmed scene in the movie, identified by a unique code and described in natural language.\nATTRIBUTES:\n- code: String\n- description: String\n- setupList: List<Setup>\nMETHODS:\n- addSetup(setup: Setup): void\n- removeSetup(setup: Setup): void\n- getSetups(): List<Setup>\n- getDescription(): String\n- getCode(): String\n\nRELATIONSHIPS:\n- Scene Aggregation Setup 1..*\n- Scene Inheritance Internal 0..1\n- Scene Inheritance External 0..1\n\nCLASS: Setup\nDescription: Represents the different filming positions for a scene, characterized by a unique code and photographic parameters.\nATTRIBUTES:\n- code: String\n- photographicParameters: String\n- scene: Scene\n- takeList: List<Take>\nMETHODS:\n- addTake(take: Take): void\n- removeTake(take: Take): void\n- getTakes(): List<Take>\n- getPhotographicParameters(): String\n- getCode(): String\n\nRELATIONSHIPS:\n- Setup Aggregation Take 1..*\n\nCLASS: Take\nDescription: Represents individual recordings made during a setup, characterized by a number, film length, and reel code.\nATTRIBUTES:\n- number: int\n- filmLength: double\n- reelCode: String\n- setup: Setup\nMETHODS:\n- getFilmLength(): double\n- getReelCode(): String\n- getNumber(): int\n\nRELATIONSHIPS:\n- None\n\nCLASS: Location\nDescription: Represents the physical place where externals are filmed, characterized by a unique code, address, and description.\nATTRIBUTES:\n- code: String\n- address: String\n- description: String\nMETHODS:\n- getAddress(): String\n- getDescription(): String\n- getCode(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: Internal\nDescription: Represents a specific type of scene filmed in a theater, distinguishing it from externals.\nATTRIBUTES:\n- scene: Scene\nMETHODS:\n- getScene(): Scene\n\nRELATIONSHIPS:\n- None\n\nCLASS: External\nDescription: Represents a specific type of scene filmed in a location, which can be further classified into \"day scene\" or \"night scene\".\nATTRIBUTES:\n- scene: Scene\n- location: Location\nMETHODS:\n- getScene(): Scene\n- getLocation(): Location\n\nRELATIONSHIPS:\n- External Association Location 1\n- External Inheritance Day Scene 0..1\n- External Inheritance Night Scene 0..1\n\nCLASS: Day Scene\nDescription: A specific subtype of external scenes that are filmed during the day.\nATTRIBUTES:\n- external: External\nMETHODS:\n- getExternal(): External\n\nRELATIONSHIPS:\n- None\n\nCLASS: Night Scene\nDescription: A specific subtype of external scenes that are filmed at night.\nATTRIBUTES:\n- external: External\nMETHODS:\n- getExternal(): External\n\nRELATIONSHIPS:\n- None\n```"
  },
  {
    "title": "Word Processor",
    "description": "A user can open a new or existing document. Text is entered through a keyboard. A document is made up of several pages and each page is made up of a header, body and footer. Date, time and page number may be added to header or footer. Document body is made up of sentences, which are themselves made up of words and punctuation characters. Words are made up of letters, digits and/or special characters. Pictures and tables may be inserted into the document body. Tables are made up of rows and columns and every cell in a table can contain both text and pictures. Users can save or print documents.",
    "textual_uml": "```\nCLASS: User\nDescription: Represents individuals who interact with the system to create, open, save, or print documents.\nATTRIBUTES:\n- username: String\n- email: String\n- password: String\n- documents: List<Document>\nMETHODS:\n- openDocument(docId: String): Document\n- saveDocument(doc: Document): void\n- printDocument(doc: Document): void\n- createDocument(): Document\n\nRELATIONSHIPS:\n- User Association Document 1..*\n- User Association Action 0..*\n\nCLASS: Document\nDescription: Represents the main entity that users work with, which can be new or existing and contains multiple pages.\nATTRIBUTES:\n- title: String\n- pages: List<Page>\n- createdDate: Date\n- modifiedDate: Date\nMETHODS:\n- addPage(page: Page): void\n- removePage(pageIndex: int): void\n- getPage(pageIndex: int): Page\n- save(): void\n- print(): void\n\nRELATIONSHIPS:\n- Document Composition Page 1..*\n\nCLASS: Page\nDescription: Represents individual pages within a document, which contain structured content like headers, bodies, and footers.\nATTRIBUTES:\n- header: Header\n- body: Body\n- footer: Footer\n- pageNumber: int\nMETHODS:\n- setHeader(header: Header): void\n- setFooter(footer: Footer): void\n- getContent(): String\n\nRELATIONSHIPS:\n- Page Composition Header 1..1\n- Page Composition Body 1..1\n- Page Composition Footer 1..1\n\nCLASS: Header\nDescription: Represents the top section of a page, which may include metadata such as date, time, and page number.\nATTRIBUTES:\n- date: Date\n- time: Time\n- pageNumber: int\nMETHODS:\n- setDate(date: Date): void\n- setTime(time: Time): void\n- setPageNumber(pageNumber: int): void\n- getHeaderInfo(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: Body\nDescription: Represents the main content area of a page where text, images, and tables are placed.\nATTRIBUTES:\n- sentences: List<Sentence>\n- pictures: List<Picture>\n- tables: List<Table>\nMETHODS:\n- addSentence(sentence: Sentence): void\n- addPicture(picture: Picture): void\n- addTable(table: Table): void\n- getContent(): String\n\nRELATIONSHIPS:\n- Body Composition Sentence 0..*\n- Body Composition Picture 0..*\n- Body Composition Table 0..*\n\nCLASS: Footer\nDescription: Represents the bottom section of a page, which may also include metadata similar to the header.\nATTRIBUTES:\n- date: Date\n- time: Time\n- pageNumber: int\nMETHODS:\n- setDate(date: Date): void\n- setTime(time: Time): void\n- setPageNumber(pageNumber: int): void\n- getFooterInfo(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: Sentence\nDescription: Represents a unit of text within the body, composed of words and punctuation characters.\nATTRIBUTES:\n- words: List<Word>\n- punctuation: List<PunctuationCharacter>\nMETHODS:\n- addWord(word: Word): void\n- addPunctuation(punctuation: PunctuationCharacter): void\n- getSentence(): String\n\nRELATIONSHIPS:\n- Sentence Composition Word 0..*\n- Sentence Composition PunctuationCharacter 0..*\n\nCLASS: Word\nDescription: Represents individual units of text that make up sentences, consisting of letters, digits, and/or special characters.\nATTRIBUTES:\n- characters: List<Character>\nMETHODS:\n- addCharacter(character: Character): void\n- getWord(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: PunctuationCharacter\nDescription: Represents symbols used in sentences to structure and clarify meaning.\nATTRIBUTES:\n- symbol: String\nMETHODS:\n- getSymbol(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: Picture\nDescription: Represents visual elements that can be inserted into the document body.\nATTRIBUTES:\n- imagePath: String\n- altText: String\nMETHODS:\n- getImagePath(): String\n- getAltText(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: Table\nDescription: Represents structured data within the document body, consisting of rows and columns.\nATTRIBUTES:\n- rows: List<Row>\n- columns: List<Column>\nMETHODS:\n- addRow(row: Row): void\n- addColumn(column: Column): void\n- getTableData(): List<List<Cell>>\n\nRELATIONSHIPS:\n- Table Composition Row 1..*\n- Table Composition Column 1..*\n\nCLASS: Row\nDescription: Represents a horizontal grouping of cells within a table.\nATTRIBUTES:\n- cells: List<Cell>\nMETHODS:\n- addCell(cell: Cell): void\n- getRowData(): List<Cell>\n\nRELATIONSHIPS:\n- None\n\nCLASS: Column\nDescription: Represents a vertical grouping of cells within a table.\nATTRIBUTES:\n- cells: List<Cell>\nMETHODS:\n- addCell(cell: Cell): void\n- getColumnData(): List<Cell>\n\nRELATIONSHIPS:\n- None\n\nCLASS: Cell\nDescription: Represents an individual unit within a table that can contain text and pictures.\nATTRIBUTES:\n- content: String\n- picture: Picture\nMETHODS:\n- setContent(content: String): void\n- setPicture(picture: Picture): void\n- getContent(): String\n\nRELATIONSHIPS:\n- Cell Association Picture 0..1\n- Cell Association Character 0..*\n\nCLASS: Character\nDescription: Represents the basic building blocks of words, which can include letters, digits, and special characters.\nATTRIBUTES:\n- value: char\nMETHODS:\n- getValue(): char\n\nRELATIONSHIPS:\n- None\n\nCLASS: Action\nDescription: Represents user actions such as opening, saving, or printing documents.\nATTRIBUTES:\n- actionType: String\n- timestamp: Date\nMETHODS:\n- execute(): void\n- getActionDetails(): String\n\nRELATIONSHIPS:\n- None\n```"
  },
  {
    "title": "Patient Record and Scheduling System",
    "description": "A patient record and scheduling system in a doctor’s office is used by the receptionists, nurses, and doctors. The receptionists use the system to enter new patient information when first-time patients visit the doctor. They also schedule all appointments. The nurses use the system to keep track of the results of each visit including diagnosis and medications. For each visit, free form text fields are used captures information on diagnosis and treatment. Multiple medications may be prescribed during each visit. The nurses can also access the information to print out a history of patient visits. The doctors primarily use the system to view patient history. The doctors may enter some patient treatment information and prescriptions occasionally, but most frequently they let the nurses enter this information. -- Each patient is assigned to a family. The head of family is responsible for the person with the primary medical coverage. Information about doctors is maintained since a family has a primary care physician, but different doctors may be the ones seeing the patient during the visit.",
    "textual_uml": "```plaintext\nCLASS: Patient\nDescription: Represents individuals receiving medical care. The system tracks their information, visit history, and treatment details.\nATTRIBUTES:\n- patientID: String\n- name: String\n- dateOfBirth: Date\n- gender: String\n- contactInfo: String\n- familyID: String\n- primaryCarePhysicianID: String\nMETHODS:\n- getPatientDetails(): Patient\n- updateContactInfo(newContactInfo: String): void\n- addVisit(visit: Visit): void\n- getPatientHistory(): PatientHistory\n\nCLASS: Family\nDescription: Represents a group of patients, with a head of family responsible for medical coverage. This entity helps in organizing patients under a common household.\nATTRIBUTES:\n- familyID: String\n- headOfFamilyID: String\n- members: List<Patient>\nMETHODS:\n- addMember(patient: Patient): void\n- removeMember(patientID: String): void\n- getFamilyMembers(): List<Patient>\n\nCLASS: Doctor\nDescription: Represents medical professionals who provide care to patients. The system maintains information about doctors, including their roles as primary care physicians.\nATTRIBUTES:\n- doctorID: String\n- name: String\n- specialization: String\n- contactInfo: String\n- patients: List<Patient>\nMETHODS:\n- getDoctorDetails(): Doctor\n- addPatient(patient: Patient): void\n- removePatient(patientID: String): void\n- viewPatientHistory(patientID: String): PatientHistory\n\nCLASS: Receptionist\nDescription: Represents staff members who manage patient information and appointments. They are key users of the system for entering new patient data and scheduling.\nATTRIBUTES:\n- receptionistID: String\n- name: String\n- contactInfo: String\nMETHODS:\n- addNewPatient(patient: Patient): void\n- scheduleAppointment(appointment: Appointment): void\n- updatePatientInfo(patient: Patient): void\n\nCLASS: Nurse\nDescription: Represents healthcare professionals who track patient visits, diagnoses, and medications. They play a crucial role in managing patient records and treatment information.\nATTRIBUTES:\n- nurseID: String\n- name: String\n- contactInfo: String\nMETHODS:\n- recordVisit(visit: Visit): void\n- updateDiagnosis(visitID: String, diagnosis: Diagnosis): void\n- prescribeMedication(visitID: String, medication: Medication): void\n- printPatientHistory(patientID: String): void\n\nCLASS: Appointment\nDescription: Represents scheduled visits between patients and doctors. This entity is essential for managing the timing and organization of patient care.\nATTRIBUTES:\n- appointmentID: String\n- patientID: String\n- doctorID: String\n- dateTime: Date\n- status: String\nMETHODS:\n- getAppointmentDetails(): Appointment\n- reschedule(newDateTime: Date): void\n- cancel(): void\n\nCLASS: Visit\nDescription: Represents individual instances of patient consultations with healthcare providers. Each visit includes details such as diagnosis, treatment, and medications prescribed.\nATTRIBUTES:\n- visitID: String\n- patientID: String\n- doctorID: String\n- dateTime: Date\n- diagnosis: Diagnosis\n- treatment: Treatment\n- medications: List<Medication>\nMETHODS:\n- getVisitDetails(): Visit\n- addDiagnosis(diagnosis: Diagnosis): void\n- addTreatment(treatment: Treatment): void\n- addMedication(medication: Medication): void\n\nCLASS: Diagnosis\nDescription: Represents the identification of a medical condition based on patient visits. It is a key component of patient records and treatment plans.\nATTRIBUTES:\n- diagnosisID: String\n- description: String\n- dateDiagnosed: Date\nMETHODS:\n- getDiagnosisDetails(): Diagnosis\n- updateDescription(newDescription: String): void\n\nCLASS: Medication\nDescription: Represents prescribed drugs for patients. Multiple medications can be associated with a single visit, making this entity important for treatment tracking.\nATTRIBUTES:\n- medicationID: String\n- name: String\n- dosage: String\n- frequency: String\nMETHODS:\n- getMedicationDetails(): Medication\n- updateDosage(newDosage: String): void\n\nCLASS: Treatment\nDescription: Represents the care provided to patients during visits, including procedures and therapies. It is essential for documenting patient care.\nATTRIBUTES:\n- treatmentID: String\n- description: String\n- dateAdministered: Date\nMETHODS:\n- getTreatmentDetails(): Treatment\n- updateDescription(newDescription: String): void\n\nCLASS: PatientHistory\nDescription: Represents the cumulative record of a patient's visits, diagnoses, and treatments over time. This is crucial for doctors to review prior to consultations.\nATTRIBUTES:\n- patientID: String\n- visits: List<Visit>\nMETHODS:\n- getHistoryDetails(): PatientHistory\n- addVisit(visit: Visit): void\n\nRELATIONSHIPS:\n- Patient Association Family 1\n- Family Aggregation Patient *\n- Patient Association Doctor 0..1\n- Doctor Aggregation Patient *\n- Receptionist Association Patient *\n- Receptionist Association Appointment *\n- Patient Association Appointment *\n- Doctor Association Appointment *\n- Visit Association Patient 1\n- Visit Association Doctor 1\n- Visit Association Diagnosis 0..*\n- Visit Association Treatment 0..*\n- Visit Association Medication 0..*\n- Diagnosis Association Visit 1\n- Medication Association Visit 1\n- Treatment Association Visit 1\n- PatientHistory Association Patient 1\n- PatientHistory Aggregation Visit *\n```"
  },
  {
    "title": "Movie-Shop",
    "description": "♣ Design a system for a movie-shop, in order to handle ordering of movies and browsing of the catalogue of the store, and user subscriptions with rechargeable cards. ♣ Only subscribers are allowed hiring movies with their own card. ♣ Credit is updated on the card during rent operations. ♣ Both users and subscribers can buy a movie and their data are saved in the related order. ♣ When a movie is not available it is ordered .",
    "textual_uml": "```\nCLASS: Movie\nDescription: Represents the films available in the shop, which can be rented or purchased by users and subscribers.\nATTRIBUTES:\n- title: String\n- genre: String\n- releaseYear: Integer\n- duration: Integer\n- price: Double\n- availability: Availability\nMETHODS:\n- getDetails(): String\n- isAvailable(): Boolean\n- orderMovie(): void\n\nRELATIONSHIPS:\n- Movie Association Availability 1..1\n\nCLASS: User\nDescription: Represents individuals who can browse the catalogue and make purchases. Users may or may not be subscribers.\nATTRIBUTES:\n- userId: String\n- name: String\n- email: String\n- isSubscriber: Boolean\nMETHODS:\n- browseCatalogue(catalogue: Catalogue): List<Movie>\n- purchaseMovie(movie: Movie): Order\n\nRELATIONSHIPS:\n- User Association Order 1..*\n\nCLASS: Subscriber\nDescription: A specialized type of User who has a subscription and can rent movies using a rechargeable card.\nATTRIBUTES:\n- subscriptionId: String\n- card: Card\nMETHODS:\n- rentMovie(movie: Movie): Rental\n- rechargeCard(amount: Double): void\n\nRELATIONSHIPS:\n- Subscriber Inheritance User 1..1\n- Subscriber Association Card 1..1\n\nCLASS: Order\nDescription: Represents the transaction details when a user or subscriber purchases or rents a movie. It contains data related to the user and the movie involved.\nATTRIBUTES:\n- orderId: String\n- user: User\n- movie: Movie\n- orderDate: Date\n- orderType: String\nMETHODS:\n- getOrderDetails(): String\n- getTotalPrice(): Double\n\nRELATIONSHIPS:\n- Order Association Movie 1..1\n- Order Association User 1..1\n\nCLASS: Card\nDescription: Represents the rechargeable card used by subscribers to rent movies. It holds credit information that is updated during rental operations.\nATTRIBUTES:\n- cardNumber: String\n- balance: Double\nMETHODS:\n- updateBalance(amount: Double): void\n- getBalance(): Double\n\nRELATIONSHIPS:\n- Card Association Subscriber 1..1\n\nCLASS: Catalogue\nDescription: Represents the collection of movies available in the shop, allowing users to browse through the available titles.\nATTRIBUTES:\n- movies: List<Movie>\nMETHODS:\n- addMovie(movie: Movie): void\n- removeMovie(movie: Movie): void\n- searchMovie(title: String): Movie\n\nRELATIONSHIPS:\n- Catalogue Aggregation Movie 0..*\n\nCLASS: Rental\nDescription: Represents the action of renting a movie, which involves updating the card's credit and may also involve creating an order.\nATTRIBUTES:\n- rentalId: String\n- subscriber: Subscriber\n- movie: Movie\n- rentalDate: Date\n- returnDate: Date\nMETHODS:\n- getRentalDetails(): String\n- calculateRentalFee(): Double\n\nRELATIONSHIPS:\n- Rental Association Subscriber 1..1\n- Rental Association Movie 1..1\n- Rental Association Order 0..1\n\nCLASS: Availability\nDescription: Represents the status of a movie in terms of whether it is available for rent or needs to be ordered.\nATTRIBUTES:\n- isAvailable: Boolean\n- quantityAvailable: Integer\nMETHODS:\n- checkAvailability(): Boolean\n- updateAvailability(quantity: Integer): void\n\nRELATIONSHIPS:\n- Availability Association Movie 1..1\n```"
  },
  {
    "title": "Flights",
    "description": "We want to model a system for management of flights and pilots. An airline operates flights. Each airline has an ID. Each flight has an ID a departure airport and an arrival airport: an airport as a unique identifier. Each flight has a pilot and a co-pilot, and it uses an aircraft of a certain type; a flight has also a departure time and an arrival time. An airline owns a set of aircrafts of different types. An aircraft can be in a working state or it can be under repair. In a particular moment an aircraft can be landed or airborne. A company has a set of pilots: each pilot has an experience level: 1 is minimum, 3 is maximum. A type of aeroplane may need a particular number of pilots, with a different role (e.g.: captain, co-pilot, navigator): there must be at least one captain and one co-pilot, and a captain must have a level 3.",
    "textual_uml": "```\nCLASS: Airline\nDescription: Represents the organization that operates flights. It has a unique identifier (ID) and owns a set of aircraft.\nATTRIBUTES:\n- id: String\n- name: String\n- aircrafts: List<Aircraft>\n- pilots: List<Pilot>\nMETHODS:\n- addAircraft(aircraft: Aircraft): void\n- removeAircraft(aircraftId: String): void\n- addPilot(pilot: Pilot): void\n- removePilot(pilotId: String): void\n- getAircrafts(): List<Aircraft>\n- getPilots(): List<Pilot>\n\nRELATIONSHIPS:\n- Airline Aggregation Aircraft 1..*\n- Airline Aggregation Pilot 1..*\n\nCLASS: Flight\nDescription: Represents a specific journey operated by an airline. It has unique attributes such as an ID, departure and arrival airports, departure and arrival times, and is associated with a pilot and co-pilot.\nATTRIBUTES:\n- id: String\n- departureAirport: Airport\n- arrivalAirport: Airport\n- departureTime: DateTime\n- arrivalTime: DateTime\n- pilot: Pilot\n- coPilot: CoPilot\n- aircraft: Aircraft\nMETHODS:\n- scheduleFlight(departure: DateTime, arrival: DateTime): void\n- getFlightDetails(): String\n- updateFlightTimes(departure: DateTime, arrival: DateTime): void\n\nRELATIONSHIPS:\n- Flight Association Airport 2\n- Flight Association Pilot 1\n- Flight Association Co-Pilot 1\n- Flight Association Aircraft 1\n\nCLASS: Airport\nDescription: Represents the locations where flights depart from and arrive at. Each airport has a unique identifier.\nATTRIBUTES:\n- id: String\n- name: String\n- location: String\nMETHODS:\n- getAirportDetails(): String\n- updateAirportInfo(name: String, location: String): void\n\nRELATIONSHIPS:\n- None\n\nCLASS: Pilot\nDescription: Represents individuals who operate the flights. Each pilot has an experience level and can have different roles (e.g., captain, co-pilot).\nATTRIBUTES:\n- id: String\n- name: String\n- experienceLevel: ExperienceLevel\nMETHODS:\n- getPilotDetails(): String\n- updateExperienceLevel(level: ExperienceLevel): void\n\nRELATIONSHIPS:\n- Pilot Association Experience Level 1\n\nCLASS: Co-Pilot\nDescription: A specific role of a pilot who assists the captain during the flight. This role is distinct but still falls under the broader category of Pilot.\nATTRIBUTES:\n- id: String (inherited)\n- name: String (inherited)\n- experienceLevel: ExperienceLevel (inherited)\nMETHODS:\n- getCoPilotDetails(): String (inherited)\n- updateExperienceLevel(level: ExperienceLevel): void (inherited)\n\nRELATIONSHIPS:\n- Pilot Inheritance Co-Pilot 1\n\nCLASS: Aircraft\nDescription: Represents the physical planes used for flights. Each aircraft has a type and can be in different states (working or under repair) and statuses (landed or airborne).\nATTRIBUTES:\n- id: String\n- type: AeroplaneType\n- state: String (e.g., \"working\", \"under repair\")\n- status: String (e.g., \"landed\", \"airborne\")\nMETHODS:\n- getAircraftDetails(): String\n- updateState(state: String): void\n- updateStatus(status: String): void\n\nRELATIONSHIPS:\n- Aircraft Association Aeroplane Type 1\n\nCLASS: Experience Level\nDescription: Represents the proficiency of pilots, which is categorized into levels (1 to 3).\nATTRIBUTES:\n- level: int (1 to 3)\nMETHODS:\n- getLevelDescription(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: Aeroplane Type\nDescription: Represents the classification of aircraft that may require a specific number of pilots with different roles.\nATTRIBUTES:\n- id: String\n- name: String\n- requiredPilots: int (number of pilots required for this type)\nMETHODS:\n- getAeroplaneTypeDetails(): String\n- updateRequiredPilots(count: int): void\n\nRELATIONSHIPS:\n- Aeroplane Type Association Pilot 1..*\n```"
  },
  {
    "title": "Bank System",
    "description": "A bank system contains data on customers (identified by name and address) and their accounts. Each account has a balance and there are 2 type of accounts: one for savings which offers an interest rate, the other for investments, used to buy stocks. Stocks are bought at a certain quantity for a certain price (ticker) and the bank applies commission on stock orders.",
    "textual_uml": "```\nCLASS: Customer\nDescription: Represents individuals who hold accounts in the bank, identified by attributes such as name and address.\nATTRIBUTES:\n- name: String\n- address: String\n- customerID: String\nMETHODS:\n- getName(): String\n- getAddress(): String\n- updateAddress(newAddress: String): void\n- getCustomerID(): String\n\nCLASS: Account\nDescription: A general representation of a financial account held by a customer, with attributes like balance and account type.\nATTRIBUTES:\n- balance: Double\n- accountNumber: String\n- accountType: String\nMETHODS:\n- getBalance(): Double\n- deposit(amount: Double): void\n- withdraw(amount: Double): void\n- getAccountNumber(): String\n- getAccountType(): String\n\nCLASS: SavingsAccount\nDescription: A specific type of account that offers an interest rate, inheriting from the Account class.\nATTRIBUTES:\n- interestRate: Double\nMETHODS:\n- calculateInterest(): Double\n- applyInterest(): void\n\nCLASS: InvestmentAccount\nDescription: A specific type of account used for buying stocks, inheriting from the Account class.\nATTRIBUTES:\n- stocks: List<Stock>\nMETHODS:\n- buyStock(stock: Stock, quantity: int): void\n- sellStock(stock: Stock, quantity: int): void\n- getStocks(): List<Stock>\n\nCLASS: Stock\nDescription: Represents the financial instruments that can be bought and sold within investment accounts, including attributes like quantity and price (ticker).\nATTRIBUTES:\n- ticker: String\n- quantity: int\n- price: Double\nMETHODS:\n- getTicker(): String\n- getQuantity(): int\n- getPrice(): Double\n- updatePrice(newPrice: Double): void\n\nCLASS: Commission\nDescription: Represents the fee applied by the bank on stock orders, affecting transactions made in investment accounts.\nATTRIBUTES:\n- rate: Double\nMETHODS:\n- calculateCommission(amount: Double): Double\n- getRate(): Double\n\nRELATIONSHIPS:\n- Customer -- Association -- Account 1..*\n- Account -- Inheritance -- SavingsAccount 1\n- Account -- Inheritance -- InvestmentAccount 1\n- InvestmentAccount -- Aggregation -- Stock 0..*\n- Commission -- Association -- InvestmentAccount 0..*\n- Stock -- Association -- Commission 0..*\n```"
  },
  {
    "title": "Veterinary Clinic",
    "description": "The owner of a veterinary clinic wants to create a database to store information about all veterinary services performed. After some research he came up with the following requirements: ● For each admitted animal, its name, breed (if any) and owner must be stored. Each animal should be given an unique numeric identifier. ● For each owner, its name, address and phone number should be stored. An unique numeric identifier should also be generated for each one of them. ● An animal might be owner-less. This happens frequently as the clinic often rescues abandoned dogs from the streets in order to treat them and get them new owners. ● It should be possible to store information about a specific breed even if no animals of that breed have been treated at the clinic. ● Each appointement always has a responsible physician. All appointements start at a certain date and time; and are attended by an animal (and of course its owner). ● For each physician, his name, address and phone number should be stored. An unique numeric identifier should also be generated for each one of them. ● In an appointement, several medical conditions might be detected. Each condition has a common name and a scientific name. No two conditions have the same scientific name. ● It should be possible to store information about the most common conditions for each different breed in the database.",
    "textual_uml": "```plaintext\nCLASS: Animal\nDescription: Represents the animals admitted to the veterinary clinic. Each animal has attributes like name, breed, and a unique identifier.\nATTRIBUTES:\n- name: String\n- breed: Breed\n- owner: Owner\n- identifier: int\nMETHODS:\n- getName(): String\n- getBreed(): Breed\n- getOwner(): Owner\n- getIdentifier(): int\n- setName(name: String): void\n- setBreed(breed: Breed): void\n- setOwner(owner: Owner): void\n\nCLASS: Owner\nDescription: Represents the owners of the animals. Each owner has attributes such as name, address, phone number, and a unique identifier. The owner can also be absent for certain animals.\nATTRIBUTES:\n- name: String\n- address: String\n- phoneNumber: String\n- identifier: int\nMETHODS:\n- getName(): String\n- getAddress(): String\n- getPhoneNumber(): String\n- getIdentifier(): int\n- setName(name: String): void\n- setAddress(address: String): void\n- setPhoneNumber(phoneNumber: String): void\n\nCLASS: Breed\nDescription: Represents the different breeds of animals. This class is necessary to store information about breeds, even if no animals of that breed are currently treated at the clinic.\nATTRIBUTES:\n- name: String\n- identifier: int\nMETHODS:\n- getName(): String\n- getIdentifier(): int\n- setName(name: String): void\n\nCLASS: Appointment\nDescription: Represents the scheduled visits to the clinic. Each appointment is associated with a specific animal, its owner, and a responsible physician, along with a date and time.\nATTRIBUTES:\n- animal: Animal\n- owner: Owner\n- physician: Physician\n- dateTime: DateTime\nMETHODS:\n- getAnimal(): Animal\n- getOwner(): Owner\n- getPhysician(): Physician\n- getDateTime(): DateTime\n- setAnimal(animal: Animal): void\n- setOwner(owner: Owner): void\n- setPhysician(physician: Physician): void\n- setDateTime(dateTime: DateTime): void\n\nCLASS: Physician\nDescription: Represents the veterinarians or doctors responsible for treating the animals. Each physician has attributes like name, address, phone number, and a unique identifier.\nATTRIBUTES:\n- name: String\n- address: String\n- phoneNumber: String\n- identifier: int\nMETHODS:\n- getName(): String\n- getAddress(): String\n- getPhoneNumber(): String\n- getIdentifier(): int\n- setName(name: String): void\n- setAddress(address: String): void\n- setPhoneNumber(phoneNumber: String): void\n\nCLASS: MedicalCondition\nDescription: Represents the various medical conditions that can be detected during an appointment. Each condition has a common name and a scientific name, with the requirement that no two conditions share the same scientific name.\nATTRIBUTES:\n- commonName: String\n- scientificName: String\nMETHODS:\n- getCommonName(): String\n- getScientificName(): String\n- setCommonName(commonName: String): void\n- setScientificName(scientificName: String): void\n\nCLASS: CommonCondition\nDescription: Represents the common medical conditions associated with specific breeds. This class is necessary to link breeds with their common medical conditions.\nATTRIBUTES:\n- breed: Breed\n- medicalCondition: MedicalCondition\nMETHODS:\n- getBreed(): Breed\n- getMedicalCondition(): MedicalCondition\n- setBreed(breed: Breed): void\n- setMedicalCondition(medicalCondition: MedicalCondition): void\n\nRELATIONSHIPS:\n- Animal Association Owner 0..1\n- Animal Association Breed 0..1\n- Owner Aggregation Animal 1..*\n- Appointment Association Animal 1\n- Appointment Association Owner 1\n- Appointment Association Physician 1\n- Appointment Aggregation MedicalCondition 0..*\n- Breed Aggregation CommonCondition 1..*\n- CommonCondition Association MedicalCondition 1\n```"
  },
  {
    "title": "Auto Repair",
    "description": "An auto repair shop, that sells and mounts parts and accessories for all kinds of vehicles, wants a new information system to manage their clients, parts, accessories and assembly services: ● There are several employees. Each one of them has an unique identifying number, a name and an address. ● In this shop, assembly services, where parts and accessories are installed in a vehicle, are executed. For each one these services the following data must be stored: In which car the service was executed, how many kms had the car at the time, who was the responsible employee, which parts and accessories were fitted, how many work hours did it take and the admission and finish dates. ● Parts and accessories are only sold together with an assembly service. ● Each part/accessory only fits in some car models. Therefore, it is important to store that information. ● Each part/accessory has a category (radio, tyre, …), a serial number and a price. ● Each car has a license plate, a make, a model, a color and an owner. Each owner has a name, identifying number, address and a phone. ● One person can own more than one car but one car only has one owner.",
    "textual_uml": "```plaintext\nCLASS: Employee\nDescription: Represents an employee in the auto repair shop responsible for executing assembly services.\nATTRIBUTES:\n- employeeID: int\n- name: String\n- address: String\nMETHODS:\n- getEmployeeID(): int\n- getName(): String\n- getAddress(): String\n- setName(name: String): void\n- setAddress(address: String): void\n\nRELATIONSHIPS:\n- Employee Association Service 1..*\n\nCLASS: Client\nDescription: Represents a car owner who has one or more vehicles serviced at the auto repair shop.\nATTRIBUTES:\n- clientID: int\n- name: String\n- address: String\n- phoneNumber: String\nMETHODS:\n- getClientID(): int\n- getName(): String\n- getAddress(): String\n- getPhoneNumber(): String\n- setName(name: String): void\n- setAddress(address: String): void\n- setPhoneNumber(phoneNumber: String): void\n\nRELATIONSHIPS:\n- Client Association Car 1..*\n\nCLASS: Car\nDescription: Represents a vehicle that receives services at the auto repair shop.\nATTRIBUTES:\n- licensePlate: String\n- make: String\n- model: String\n- color: String\n- owner: Client\nMETHODS:\n- getLicensePlate(): String\n- getMake(): String\n- getModel(): String\n- getColor(): String\n- getOwner(): Client\n- setMake(make: String): void\n- setModel(model: String): void\n- setColor(color: String): void\n\nRELATIONSHIPS:\n- Car Association Service 1..*\n\nCLASS: Service\nDescription: Represents an assembly service performed on a car, including details about the car, employee, and parts/accessories used.\nATTRIBUTES:\n- car: Car\n- kilometersAtService: int\n- responsibleEmployee: Employee\n- fittedParts: List<Part>\n- fittedAccessories: List<Accessory>\n- workHours: float\n- admissionDate: Date\n- finishDate: Date\nMETHODS:\n- getCar(): Car\n- getKilometersAtService(): int\n- getResponsibleEmployee(): Employee\n- getFittedParts(): List<Part>\n- getFittedAccessories(): List<Accessory>\n- getWorkHours(): float\n- getAdmissionDate(): Date\n- getFinishDate(): Date\n- addPart(part: Part): void\n- addAccessory(accessory: Accessory): void\n\nRELATIONSHIPS:\n- Service Composition Part 0..*\n- Service Composition Accessory 0..*\n\nCLASS: Part\nDescription: Represents a component that can be sold and installed in vehicles, with specific attributes for categorization and compatibility.\nATTRIBUTES:\n- category: Category\n- serialNumber: String\n- price: float\n- compatibleModels: List<Model>\nMETHODS:\n- getCategory(): Category\n- getSerialNumber(): String\n- getPrice(): float\n- getCompatibleModels(): List<Model>\n- setPrice(price: float): void\n\nRELATIONSHIPS:\n- Part Association Category 1\n- Part Association Model 0..*\n\nCLASS: Accessory\nDescription: Represents an accessory that can be sold and installed in vehicles, similar to parts but serving different purposes.\nATTRIBUTES:\n- category: Category\n- serialNumber: String\n- price: float\n- compatibleModels: List<Model>\nMETHODS:\n- getCategory(): Category\n- getSerialNumber(): String\n- getPrice(): float\n- getCompatibleModels(): List<Model>\n- setPrice(price: float): void\n\nRELATIONSHIPS:\n- Accessory Association Category 1\n- Accessory Association Model 0..*\n\nCLASS: Category\nDescription: Represents a classification for parts and accessories, helping to organize inventory.\nATTRIBUTES:\n- categoryID: int\n- name: String\nMETHODS:\n- getCategoryID(): int\n- getName(): String\n- setName(name: String): void\n\nRELATIONSHIPS:\n- Category Association Part 0..*\n- Category Association Accessory 0..*\n- Category Association Model 0..*\n\nCLASS: Model\nDescription: Represents a car model, which is important for determining compatibility with parts and accessories.\nATTRIBUTES:\n- modelID: int\n- name: String\n- make: String\nMETHODS:\n- getModelID(): int\n- getName(): String\n- getMake(): String\n- setName(name: String): void\n- setMake(make: String): void\n\nRELATIONSHIPS:\n- Model Association Part 0..*\n- Model Association Accessory 0..*\n- Model Association Category 0..*\n```"
  },
  {
    "title": "Restaurant",
    "description": "The owner of a small restaurant wants a new information system to store data for all meals consumed there and also to keep a record of ingredients kept in stock. After some research he reached the following requirements list: ● Each ingredient has a name, a measuring unit (e.g. olive oil is measured in liters, while eggs are unit based) and a quantity in stock. There are no two ingredients with the same name. ● Each dish is composed of several ingredients in a certain quantity. An ingredient can, of course, be used in different dishes. ● A dish has an unique name and a numeric identifier. ● There are several tables at the restaurant. Each one of them has an unique numeric identifier and a maximum ammount of people that can be seated there. ● In each meal, several dishes are consumed at a certain table. The same dish can be eaten more than once in the same meal. ● A meal takes place in a certain date and has a start and end time. Each meal has a responsible waiter. ● A waiter has an unique numerical identifier, a name, an address and a phone number. ● In some cases it is important to store information about the client that consumed the meal. A client has a tax identification number, a name and an address.",
    "textual_uml": "```\nCLASS: Ingredient\nDescription: Represents the individual components used to prepare dishes. Each ingredient has attributes such as name, measuring unit, and quantity in stock.\nATTRIBUTES:\n- name: String\n- measuringUnit: String\n- quantityInStock: Float\nMETHODS:\n- getName(): String\n- getMeasuringUnit(): String\n- getQuantityInStock(): Float\n- updateQuantity(amount: Float): void\n\nRELATIONSHIPS:\n- Ingredient Composition Dish 1..*\n\nCLASS: Dish\nDescription: Represents a specific meal item that is composed of multiple ingredients. Each dish has a unique name and a numeric identifier.\nATTRIBUTES:\n- name: String\n- id: Integer\n- ingredients: List<Ingredient>\nMETHODS:\n- getName(): String\n- getId(): Integer\n- getIngredients(): List<Ingredient>\n- addIngredient(ingredient: Ingredient, quantity: Float): void\n\nRELATIONSHIPS:\n- Dish Association Meal 0..*\n\nCLASS: Table\nDescription: Represents the physical seating arrangements in the restaurant. Each table has a unique numeric identifier and a maximum capacity for guests.\nATTRIBUTES:\n- id: Integer\n- maxCapacity: Integer\nMETHODS:\n- getId(): Integer\n- getMaxCapacity(): Integer\n- isAvailable(): Boolean\n\nRELATIONSHIPS:\n- Table Association Meal 1..*\n\nCLASS: Meal\nDescription: Represents an event where dishes are consumed at a table. Each meal has a specific date, start and end times, and is associated with a waiter.\nATTRIBUTES:\n- date: Date\n- startTime: Time\n- endTime: Time\n- table: Table\n- waiter: Waiter\n- dishes: List<Dish>\nMETHODS:\n- getDate(): Date\n- getStartTime(): Time\n- getEndTime(): Time\n- getTable(): Table\n- getWaiter(): Waiter\n- getDishes(): List<Dish>\n- addDish(dish: Dish): void\n\nRELATIONSHIPS:\n- Meal Association Client 0..*\n- Meal Association Waiter 1..*\n- Meal Association Table 1..*\n\nCLASS: Waiter\nDescription: Represents the staff member responsible for serving meals. Each waiter has a unique identifier, name, address, and phone number.\nATTRIBUTES:\n- id: Integer\n- name: String\n- address: String\n- phoneNumber: String\nMETHODS:\n- getId(): Integer\n- getName(): String\n- getAddress(): String\n- getPhoneNumber(): String\n\nRELATIONSHIPS:\n- Waiter Association Meal 1..*\n\nCLASS: Client\nDescription: Represents the customers who consume meals at the restaurant. Each client has a tax identification number, name, and address.\nATTRIBUTES:\n- taxId: String\n- name: String\n- address: String\nMETHODS:\n- getTaxId(): String\n- getName(): String\n- getAddress(): String\n\nRELATIONSHIPS:\n- Client Association Meal 0..*\n```"
  },
  {
    "title": "Deliveries",
    "description": "The owner of a small delivery company plans to have an information system that allows him to save data about his customers and deliveries. After some time studying the problem, he reached the following requirements: ● Each customer has a VAT number, a name, a phone number and an address. There are no two clients with the same VAT number. ● When a customer wants to send a package to another customer, he just has to login to the company website, select the customer he wants to send the package to, enter the package’s weight and if the delivery is normal or urgent. He then receives an unique identifier code that he writes on the package. ● The package is then delivered by the customer at the delivery center of his choosing. A delivery center has a unique name and an address. ● Each client has an associated delivery center. This delivery center is chosen by the company and it is normally the one closest to the customer’s house. ● The package is them routed through an internal system until it reaches the delivery center of the recipient. ● The package is then delivered by hand from that delivery center to the recipient by a courier. ● Couriers have a single VAT number, a name and a phone number. Each courier works in a single delivery center. ● A courier is assigned to a packet as soon as the packet is introduced in the system.",
    "textual_uml": "```plaintext\nCLASS: Customer\nDescription: Represents individuals or entities that use the delivery service. Each customer has unique attributes such as a VAT number, name, phone number, and address.\nATTRIBUTES:\n- vatNumber: String\n- name: String\n- phoneNumber: String\n- address: String\n- deliveryCenter: DeliveryCenter\nMETHODS:\n- login(username: String, password: String): Boolean\n- sendPackage(recipient: Customer, weight: Double, deliveryType: String): String\n- getDeliveryCenter(): DeliveryCenter\n\nCLASS: Package\nDescription: Represents the item being sent from one customer to another. It has attributes like weight, delivery type (normal or urgent), and a unique identifier code.\nATTRIBUTES:\n- identifierCode: String\n- weight: Double\n- deliveryType: String\n- sender: Customer\n- recipient: Customer\n- status: String\nMETHODS:\n- getDetails(): String\n- updateStatus(newStatus: String): void\n\nCLASS: DeliveryCenter\nDescription: Represents the physical location where packages are delivered and picked up. Each delivery center has a unique name and address, and is associated with customers.\nATTRIBUTES:\n- name: String\n- address: String\n- customers: List<Customer>\nMETHODS:\n- addCustomer(customer: Customer): void\n- getCustomers(): List<Customer>\n\nCLASS: Courier\nDescription: Represents individuals responsible for delivering packages from the delivery center to the recipient. Each courier has a VAT number, name, phone number, and is associated with a single delivery center.\nATTRIBUTES:\n- vatNumber: String\n- name: String\n- phoneNumber: String\n- deliveryCenter: DeliveryCenter\nMETHODS:\n- assignPackage(package: Package): void\n- getDeliveryCenter(): DeliveryCenter\n\nCLASS: Delivery\nDescription: Represents the process of transporting a package from the sender's delivery center to the recipient's delivery center. This class may encapsulate the routing and handling of the package during transit.\nATTRIBUTES:\n- package: Package\n- courier: Courier\n- fromCenter: DeliveryCenter\n- toCenter: DeliveryCenter\nMETHODS:\n- startDelivery(): void\n- completeDelivery(): void\n- getDeliveryStatus(): String\n\nRELATIONSHIPS:\n- Customer Association DeliveryCenter 1..1\n- Customer Association Package 1..*\n- Package Association Customer 1..1\n- DeliveryCenter Aggregation Customer 1..*\n- DeliveryCenter Association Courier 1..*\n- Courier Association Delivery 1..*\n- Package Association Delivery 1..1\n- Delivery Association DeliveryCenter 1..2\n```"
  },
  {
    "title": "Furniture",
    "description": "The known furniture factory Hi-Key-Ah, intends to implement an information system to store all data on the different types of furniture and components it produces: ● The factory produces several lines of furniture, each with a different name and consisting of several pieces of furniture of different types (beds, tables, chairs, …). ● All furniture pieces have a type, a single reference (eg CC6578) and a selling price. ● The major competitive advantage of this innovative plant is the fact that each component produced can be used in more than one piece of furniture. ● Each piece of furniture is thus composed of several components. The same component can be used more than once in the same piece. ● Every type of component produced is assigned a unique numerical code, a manufacturing price and a type (screw, hinge, shelf …). ● The furniture is then sold in various stores throughout the world. Each store has a different address and a fax number. ● To make the manufacturing process more efficient, stores have to place orders everytime they need to replenish their stock. These orders must also be stored in the database. ● Each order has a order number, a date, the store that placed the order as well as a list of all the ordered furniture and their quantities.",
    "textual_uml": "```plaintext\nCLASS: FurnitureLine\nDescription: Represents the different lines of furniture produced by the factory, each with a unique name and consisting of various pieces of furniture.\nATTRIBUTES:\n- name: String\n- furniturePieces: List<FurniturePiece>\nMETHODS:\n- addFurniturePiece(piece: FurniturePiece): void\n- removeFurniturePiece(piece: FurniturePiece): void\n- getFurniturePieces(): List<FurniturePiece>\n\nRELATIONSHIPS:\n- FurnitureLine Aggregation FurniturePiece 1..*\n\nCLASS: FurniturePiece\nDescription: Represents individual pieces of furniture (e.g., beds, tables, chairs) that belong to a furniture line. Each piece has a type, reference, and selling price.\nATTRIBUTES:\n- type: String\n- reference: String\n- sellingPrice: double\n- components: List<Component>\nMETHODS:\n- addComponent(component: Component): void\n- removeComponent(component: Component): void\n- getComponents(): List<Component>\n\nRELATIONSHIPS:\n- FurniturePiece Composition Component 0..*\n\nCLASS: Component\nDescription: Represents the individual components (e.g., screws, hinges, shelves) used to assemble furniture pieces. Each component has a unique numerical code, manufacturing price, and type.\nATTRIBUTES:\n- code: int\n- manufacturingPrice: double\n- type: String\nMETHODS:\n- getCode(): int\n- getManufacturingPrice(): double\n- getType(): String\n\nRELATIONSHIPS:\n(No relationships defined)\n\nCLASS: Store\nDescription: Represents the various stores that sell the furniture. Each store has a unique address and fax number.\nATTRIBUTES:\n- address: String\n- faxNumber: String\nMETHODS:\n- getAddress(): String\n- getFaxNumber(): String\n- updateAddress(newAddress: String): void\n\nRELATIONSHIPS:\n- Store Association Order 1..*\n\nCLASS: Order\nDescription: Represents the orders placed by stores to replenish their stock. Each order has an order number, date, associated store, and a list of ordered furniture pieces with their quantities.\nATTRIBUTES:\n- orderNumber: String\n- date: Date\n- store: Store\n- orderItems: List<OrderItem>\nMETHODS:\n- addOrderItem(item: OrderItem): void\n- removeOrderItem(item: OrderItem): void\n- getOrderItems(): List<OrderItem>\n\nRELATIONSHIPS:\n- Order Aggregation OrderItem 1..*\n\nCLASS: OrderItem\nDescription: Represents the individual items within an order, detailing the specific furniture pieces ordered and their quantities. This class helps manage the relationship between orders and the furniture pieces.\nATTRIBUTES:\n- furniturePiece: FurniturePiece\n- quantity: int\nMETHODS:\n- getFurniturePiece(): FurniturePiece\n- getQuantity(): int\n- setQuantity(newQuantity: int): void\n\nRELATIONSHIPS:\n- OrderItem Association FurniturePiece 1\n```"
  },
  {
    "title": "Factory",
    "description": "Create a database for a factory with the following requirements. Don’t forget to add unique identifiers for each one of the entities if needed. ● A factory has several machines. Each one of them is operated by several workers. ● A worker might work in more than one machine. ● In this factory, several products of different types, are produced. Each different type of product is produced in a single machine. But, the same machine can produce more than one type of product. ● Products from the same type are all produced from the same single material and have the same weigth. ● Clients can issue purchase orders. Each order has a list of the desired products and their quantity. ● For each worker, the following data should be stored in the database: name (first and last), birth date, address and a list of his skills. ● For each machine, the following data should be stored: serial number, make, model and purchase date. ● For each client, the followig data should be stored: name, address, phone number and name of the contact person (if any). ● For each purchase order, the following date should be stored: order number, date it has been made, expected and actual delivery date.",
    "textual_uml": "```plaintext\nCLASS: Factory\nDescription: Represents the overall entity that encompasses machines, workers, products, and clients. It serves as the central point of operations.\nATTRIBUTES:\n- factoryId: int\n- name: String\n- location: String\n- machines: List<Machine>\n- workers: List<Worker>\n- products: List<Product>\n- clients: List<Client>\nMETHODS:\n- addMachine(machine: Machine): void\n- removeMachine(machineId: int): void\n- addWorker(worker: Worker): void\n- removeWorker(workerId: int): void\n- addProduct(product: Product): void\n- addClient(client: Client): void\n- createPurchaseOrder(order: PurchaseOrder): void\n\nRELATIONSHIPS:\n- Factory Aggregation Machine 1 -- *\n- Factory Aggregation Worker 1 -- *\n- Factory Aggregation Product 1 -- *\n- Factory Aggregation Client 1 -- *\n\nCLASS: Machine\nDescription: Represents the physical machines in the factory that produce products. Each machine has specific attributes like serial number, make, model, and purchase date.\nATTRIBUTES:\n- serialNumber: String\n- make: String\n- model: String\n- purchaseDate: Date\n- products: List<Product>\n- workers: List<Worker>\nMETHODS:\n- addProduct(product: Product): void\n- removeProduct(productId: int): void\n- assignWorker(worker: Worker): void\n- removeWorker(workerId: int): void\n\nRELATIONSHIPS:\n- Machine Composition Product 1 -- *\n- Machine Association Worker * -- *\n\nCLASS: Worker\nDescription: Represents the individuals who operate the machines. Workers have attributes such as name, birth date, address, and a list of skills, indicating their qualifications and personal information.\nATTRIBUTES:\n- workerId: int\n- firstName: String\n- lastName: String\n- birthDate: Date\n- address: String\n- skills: List<Skill>\n- machines: List<Machine>\nMETHODS:\n- addSkill(skill: Skill): void\n- removeSkill(skillId: int): void\n- assignMachine(machine: Machine): void\n- removeMachine(machineId: int): void\n\nRELATIONSHIPS:\n- Worker Association Skill * -- *\n\nCLASS: Product\nDescription: Represents the items produced in the factory. Each product type is associated with a specific material and weight, and can be produced by multiple machines.\nATTRIBUTES:\n- productId: int\n- name: String\n- weight: double\n- material: Material\n- machine: Machine\nMETHODS:\n- getProductDetails(): String\n- updateWeight(newWeight: double): void\n\nRELATIONSHIPS:\n- Product Association Material 1 -- 1\n\nCLASS: Material\nDescription: Represents the raw materials used to produce products. Each product type is produced from a single material, which may need to be tracked for inventory and production purposes.\nATTRIBUTES:\n- materialId: int\n- name: String\n- quantityAvailable: double\nMETHODS:\n- updateQuantity(amount: double): void\n- getMaterialDetails(): String\n\nRELATIONSHIPS:\n- None\n\nCLASS: Client\nDescription: Represents the customers who place purchase orders. Clients have attributes such as name, address, phone number, and contact person, which are essential for managing orders and communications.\nATTRIBUTES:\n- clientId: int\n- name: String\n- address: String\n- phoneNumber: String\n- contactPerson: String\nMETHODS:\n- getClientDetails(): String\n- updateContactPerson(newContact: String): void\n\nRELATIONSHIPS:\n- Client Aggregation PurchaseOrder 1 -- *\n\nCLASS: PurchaseOrder\nDescription: Represents the orders placed by clients for products. Each order contains details like order number, order date, expected delivery date, actual delivery date, and a list of products with their quantities.\nATTRIBUTES:\n- orderNumber: int\n- orderDate: Date\n- expectedDeliveryDate: Date\n- actualDeliveryDate: Date\n- products: List<ProductQuantity>\nMETHODS:\n- addProduct(product: Product, quantity: int): void\n- removeProduct(productId: int): void\n- getOrderSummary(): String\n\nRELATIONSHIPS:\n- PurchaseOrder Association Product * -- *\n\nCLASS: Skill\nDescription: Represents the various skills that workers may possess. This class can be used to categorize and manage the capabilities of workers in relation to the machines they operate.\nATTRIBUTES:\n- skillId: int\n- name: String\n- description: String\nMETHODS:\n- getSkillDetails(): String\n\nRELATIONSHIPS:\n- None\n```"
  },
  {
    "title": "Bycicle Rental",
    "description": "A bicycle renting company wants to create an information system that allows it to store the data regarding all their reservations and rentals. The system should follow these requirements: ● It should be possible to store the national id number (NIN), tax identification number (TIN), name and address for every client. The NIN and TIN must be different for every client and all clients should have at least a TIN and a name. ● The database should also contain information about the bicycle models that can be rented- Each model has an unique name, a type (that can only be road, mountain, bmx or hybrid) and the number of gears. ● Each bicycle has a unique identifying number and a model. ● The company has several different stores where bicycles can be picked up and returned. Each one of these stores is identified by an unique name and has an address (both mandatory). ● When a reservation is made, the following data must be known: which client did the reservation, when will he pick up the bike (day), which bike model he wants and where will he pick up the bike (store). ● When a bike is picked up, the actual bike that was picked up must be stored in the database. ● When a bike is returned, the return date should be stored in the database.",
    "textual_uml": "```plaintext\nCLASS: Client\nDescription: Represents individuals who rent bicycles. Contains attributes such as national id number (NIN), tax identification number (TIN), name, and address.\nATTRIBUTES:\n- nationalIdNumber: String\n- taxIdentificationNumber: String\n- name: String\n- address: String\nMETHODS:\n- getNationalIdNumber(): String\n- getTaxIdentificationNumber(): String\n- getName(): String\n- getAddress(): String\n- setNationalIdNumber(nin: String): void\n- setTaxIdentificationNumber(tin: String): void\n- setName(name: String): void\n- setAddress(address: String): void\n\nRELATIONSHIPS:\n- Client Association Reservation 1..*\n- Client Association Rental 1..* (indirectly through Reservation)\n\nCLASS: BicycleModel\nDescription: Represents the different models of bicycles available for rent. Contains attributes such as unique name, type (road, mountain, bmx, hybrid), and number of gears.\nATTRIBUTES:\n- uniqueName: String\n- type: String\n- numberOfGears: int\nMETHODS:\n- getUniqueName(): String\n- getType(): String\n- getNumberOfGears(): int\n- setUniqueName(name: String): void\n- setType(type: String): void\n- setNumberOfGears(gears: int): void\n\nRELATIONSHIPS:\n- BicycleModel Association Bicycle 1..*\n- BicycleModel Association Reservation 1..*\n\nCLASS: Bicycle\nDescription: Represents the actual bicycles that can be rented. Each bicycle has a unique identifying number and is associated with a specific BicycleModel.\nATTRIBUTES:\n- uniqueId: String\n- model: BicycleModel\nMETHODS:\n- getUniqueId(): String\n- getModel(): BicycleModel\n- setUniqueId(id: String): void\n- setModel(model: BicycleModel): void\n\nRELATIONSHIPS:\n- Bicycle Association Rental 1..1\n\nCLASS: Store\nDescription: Represents the physical locations where bicycles can be picked up and returned. Each store has a unique name and an address.\nATTRIBUTES:\n- uniqueName: String\n- address: String\nMETHODS:\n- getUniqueName(): String\n- getAddress(): String\n- setUniqueName(name: String): void\n- setAddress(address: String): void\n\nRELATIONSHIPS:\n- Store Association Reservation 1..*\n- Store Association Rental 1..1\n\nCLASS: Reservation\nDescription: Represents the action of reserving a bicycle. Contains information about the client making the reservation, the date of pickup, the desired bicycle model, and the store where the bike will be picked up.\nATTRIBUTES:\n- client: Client\n- pickupDate: Date\n- bicycleModel: BicycleModel\n- store: Store\nMETHODS:\n- getClient(): Client\n- getPickupDate(): Date\n- getBicycleModel(): BicycleModel\n- getStore(): Store\n- setClient(client: Client): void\n- setPickupDate(date: Date): void\n- setBicycleModel(model: BicycleModel): void\n- setStore(store: Store): void\n\nRELATIONSHIPS:\n- Reservation Composition Rental 1..1\n\nCLASS: Rental\nDescription: Represents the actual transaction of renting a bicycle. It includes details about which specific Bicycle was picked up and the return date when the bicycle is returned.\nATTRIBUTES:\n- bicycle: Bicycle\n- pickupDate: Date\n- returnDate: Date\nMETHODS:\n- getBicycle(): Bicycle\n- getPickupDate(): Date\n- getReturnDate(): Date\n- setBicycle(bicycle: Bicycle): void\n- setPickupDate(date: Date): void\n- setReturnDate(date: Date): void\n\nRELATIONSHIPS:\n- Rental Association Bicycle 1..1\n- Rental Association Store 1..1\n```"
  },
  {
    "title": "Saturn Int. Management",
    "description": "Saturn Int. management wants to improve their security measures, both for their building and on site. They would like to prevent people who are not part of the company to use their car park. Saturn Int. has decided to issue identity cards to all employees. Each card records the name, department and number of a company staff, and give them access to the company car park. Employees are asked to wear the cards while on the site. There is a barrier and a card reader placed at the entrance to the car park. When a driver drives his car into the car park, he/she inserts his or her identity card into the card reader. The card reader then verify the card number to see if it is known to the system. If the number is recognized, the reader sends a signal to trigger the barrier to rise. The driver can then drive his/her car into the car park. There is another barrier at the exit of the car park, which is automatically raised when a car wishes to leave the car park. A sign at the entrance display “Full” when there are no spaces in the car park. It is only switched off when a car leaves. There is another type of card for guests, which also permits access to the car park. The card records a number and the current date. Such cards may be sent out in advance, or collected from reception. All guest cards must be returned to reception when the visitor leaves Saturn Int.",
    "textual_uml": "```plaintext\nCLASS: Employee\nDescription: Represents the staff members of Saturn Int. who are issued identity cards for access to the car park.\nATTRIBUTES:\n- name: String\n- department: String\n- employeeNumber: String\n- identityCard: IdentityCard\nMETHODS:\n- getName(): String\n- getDepartment(): String\n- getEmployeeNumber(): String\n- getIdentityCard(): IdentityCard\n\nCLASS: IdentityCard\nDescription: Represents the cards issued to employees and guests, containing identification information.\nATTRIBUTES:\n- cardNumber: String\n- type: String\n- dateOfIssuance: Date\nMETHODS:\n- getCardNumber(): String\n- getType(): String\n- getDateOfIssuance(): Date\n\nCLASS: CarPark\nDescription: Represents the physical location where cars are parked, managing occupancy and access.\nATTRIBUTES:\n- capacity: int\n- currentOccupancy: int\n- isFull: boolean\nMETHODS:\n- isCarParkFull(): boolean\n- addCar(): void\n- removeCar(): void\n- getCurrentOccupancy(): int\n- getCapacity(): int\n\nCLASS: Barrier\nDescription: Represents the barriers at the entrance and exit of the car park, controlling access based on identity card verification.\nATTRIBUTES:\n- isRaised: boolean\n- location: String\nMETHODS:\n- raise(): void\n- lower(): void\n- isBarrierRaised(): boolean\n\nCLASS: CardReader\nDescription: Represents the device that reads identity cards and verifies their validity for access control.\nATTRIBUTES:\n- readerID: String\n- isOperational: boolean\nMETHODS:\n- readCard(card: IdentityCard): boolean\n- verifyCard(cardNumber: String): boolean\n- sendSignalToBarrier(barrier: Barrier): void\n\nCLASS: Guest\nDescription: Represents visitors to Saturn Int. who are issued guest cards for temporary access to the car park.\nATTRIBUTES:\n- name: String\n- visitDuration: int\n- identityCard: IdentityCard\nMETHODS:\n- getName(): String\n- getVisitDuration(): int\n- getIdentityCard(): IdentityCard\n\nCLASS: Reception\nDescription: Represents the location responsible for issuing guest cards and collecting them upon the guest's departure.\nATTRIBUTES:\n- location: String\n- guestCardsIssued: List<IdentityCard>\nMETHODS:\n- issueGuestCard(guest: Guest): IdentityCard\n- collectGuestCard(card: IdentityCard): void\n- getIssuedGuestCards(): List<IdentityCard>\n\nCLASS: Sign\nDescription: Represents the display sign at the entrance of the car park indicating its occupancy status.\nATTRIBUTES:\n- message: String\n- isDisplayed: boolean\nMETHODS:\n- displayMessage(message: String): void\n- turnOff(): void\n- turnOn(): void\n- getMessage(): String\n\nRELATIONSHIPS:\n- Employee Association IdentityCard 1..1\n- Guest Association IdentityCard 1..1\n- CarPark Aggregation Barrier 1..*\n- CarPark Aggregation CardReader 1..1\n- CardReader Association Barrier 1..*\n- CarPark Composition Sign 1..1\n- Reception Aggregation IdentityCard 0..*\n- Reception Association Guest 0..*\n- Guest Association Reception 0..1\n- CarPark Association Employee 0..*\n- CarPark Association Guest 0..*\n```"
  },
  {
    "title": "OOBank",
    "description": "This system provides the basic services to manage bank accounts at a bank called OOBank. OOBank has many branches, each of which has an address and branch number. A client opens accounts at a branch. Each account is uniquely identified by an account number; it has a balance and a credit or overdraft limit. There are many types of accounts, including: a mortgage account (which has a property as collateral), a checking account, and a credit card account (which has an expiry date and can have secondary cards attached to it). It is possible to have a joint account (e.g. for a husband and wife). Each type of account has a particular interest rate, a monthly fee and a specific set of privileges (e.g. ability to write checks, insurance for purchases etc.). OOBank is divided into divisions and subdivisions (such as Planning, Investments and Consumer); the branches are considered subdivisions of the Consumer Division. Each division has a manager and a set of other employees. Each customer is assigned a particular employee as his or her ‘personal banker’.",
    "textual_uml": "```\nCLASS: Bank\nDescription: Represents the overall organization (OOBank) that manages branches and accounts.\nATTRIBUTES:\n- name: String\n- branches: List<Branch>\n- divisions: List<Division>\nMETHODS:\n- addBranch(branch: Branch): void\n- removeBranch(branch: Branch): void\n- getBranches(): List<Branch>\n- addDivision(division: Division): void\n- getDivisions(): List<Division>\n\nRELATIONSHIPS:\n- Bank Aggregation Branch 1..*\n- Bank Aggregation Division 1..*\n\nCLASS: Branch\nDescription: Represents the physical locations of the bank, each with its own address and branch number.\nATTRIBUTES:\n- address: String\n- branchNumber: String\n- accounts: List<Account>\n- employees: List<Employee>\nMETHODS:\n- addAccount(account: Account): void\n- removeAccount(account: Account): void\n- getAccounts(): List<Account>\n- addEmployee(employee: Employee): void\n- getEmployees(): List<Employee>\n\nRELATIONSHIPS:\n- Branch Aggregation Account 0..*\n- Branch Aggregation Employee 0..*\n- Division Aggregation Branch 1..*\n\nCLASS: Client\nDescription: Represents individuals who open and manage accounts at the bank.\nATTRIBUTES:\n- name: String\n- clientId: String\n- accounts: List<Account>\n- personalBanker: PersonalBanker\nMETHODS:\n- openAccount(account: Account): void\n- closeAccount(account: Account): void\n- getAccounts(): List<Account>\n- setPersonalBanker(banker: PersonalBanker): void\n\nRELATIONSHIPS:\n- Client Association Account 0..*\n- Client Association PersonalBanker 0..1\n\nCLASS: Account\nDescription: Represents the financial accounts held by clients, which can be of various types and have unique identifiers.\nATTRIBUTES:\n- accountNumber: String\n- balance: double\n- creditLimit: double\n- accountType: AccountType\nMETHODS:\n- deposit(amount: double): void\n- withdraw(amount: double): void\n- getBalance(): double\n- getAccountType(): AccountType\n\nRELATIONSHIPS:\n- Account Inheritance MortgageAccount 0..*\n- Account Inheritance CheckingAccount 0..*\n- Account Inheritance CreditCardAccount 0..*\n- Account Inheritance JointAccount 0..*\n- AccountType Association Account 1..*\n\nCLASS: MortgageAccount\nDescription: A specific type of account that includes a property as collateral, representing a common financial product.\nATTRIBUTES:\n- propertyCollateral: String\n- interestRate: double\n- monthlyFee: double\nMETHODS:\n- calculateMonthlyPayment(): double\n- getPropertyCollateral(): String\n\nCLASS: CheckingAccount\nDescription: Another specific type of account that allows clients to manage day-to-day transactions.\nATTRIBUTES:\n- overdraftLimit: double\n- interestRate: double\n- monthlyFee: double\nMETHODS:\n- writeCheck(amount: double): void\n- getOverdraftLimit(): double\n\nCLASS: CreditCardAccount\nDescription: A type of account that involves credit and has specific features like an expiry date and secondary cards.\nATTRIBUTES:\n- expiryDate: Date\n- secondaryCards: List<String>\n- interestRate: double\n- monthlyFee: double\nMETHODS:\n- addSecondaryCard(cardHolderName: String): void\n- removeSecondaryCard(cardHolderName: String): void\n- isExpired(): boolean\n\nCLASS: JointAccount\nDescription: Represents accounts that are shared between multiple clients, such as couples.\nATTRIBUTES:\n- accountHolders: List<Client>\n- interestRate: double\n- monthlyFee: double\nMETHODS:\n- addAccountHolder(client: Client): void\n- removeAccountHolder(client: Client): void\n- getAccountHolders(): List<Client>\n\nCLASS: Division\nDescription: Represents the organizational structure of the bank, categorizing branches into divisions like Planning, Investments, and Consumer.\nATTRIBUTES:\n- name: String\n- branches: List<Branch>\n- manager: Manager\nMETHODS:\n- addBranch(branch: Branch): void\n- removeBranch(branch: Branch): void\n- getBranches(): List<Branch>\n\nRELATIONSHIPS:\n- Division Aggregation Branch 1..*\n- Division Association Manager 1..1\n\nCLASS: Subdivision\nDescription: Represents a more granular level within divisions, specifically referring to branches as subdivisions of the Consumer Division.\nATTRIBUTES:\n- name: String\n- branches: List<Branch>\nMETHODS:\n- addBranch(branch: Branch): void\n- removeBranch(branch: Branch): void\n- getBranches(): List<Branch>\n\nCLASS: Employee\nDescription: Represents individuals who work at the bank, including managers and personal bankers.\nATTRIBUTES:\n- name: String\n- employeeId: String\n- position: String\n- branch: Branch\nMETHODS:\n- getPosition(): String\n- setBranch(branch: Branch): void\n\nCLASS: Manager\nDescription: A specific type of employee responsible for overseeing a division.\nATTRIBUTES:\n- division: Division\nMETHODS:\n- getDivision(): Division\n\nRELATIONSHIPS:\n- Manager Inheritance Employee 1..1\n\nCLASS: PersonalBanker\nDescription: A specific role of an employee assigned to assist individual clients with their banking needs.\nATTRIBUTES:\n- clients: List<Client>\nMETHODS:\n- addClient(client: Client): void\n- removeClient(client: Client): void\n- getClients(): List<Client>\n\nRELATIONSHIPS:\n- PersonalBanker Inheritance Employee 1..1\n\nCLASS: AccountType\nDescription: Represents the various types of accounts (e.g., mortgage, checking, credit card) that have distinct features like interest rates and fees.\nATTRIBUTES:\n- typeName: String\n- interestRate: double\n- monthlyFee: double\n- privileges: List<Privilege>\nMETHODS:\n- getPrivileges(): List<Privilege>\n\nCLASS: Privilege\nDescription: Represents the specific benefits or features associated with different account types, such as the ability to write checks or insurance for purchases.\nATTRIBUTES:\n- privilegeName: String\n- description: String\nMETHODS:\n- getDescription(): String\n\nRELATIONSHIPS:\n- AccountType Aggregation Privilege 0..*\n```"
  },
  {
    "title": "Prepaid Cell Phone",
    "description": "The contract of a prepaid cell phone should be modelled and implemented. A basic contract has a contract number (of type int) and a balance (of type double), but no monthly charges. The contract number is not automatically generated, but is to be set as a parameter by the constructor as well as the initial balance. The balance has a getter and a setter. The following options can be added to a contract (if needed also several times): ● 100 MB of data (monthly charge 1.00€) ● 50 SMS (monthly charge 0.50€) ● 50 minutes (monthly charge 1.50€) ● Double Transfer Rate (monthly charge 2.00€) implement this requirement with the help of the decorator pattern. All contract elements should be able to understand the methods getCharges():double, getBalance():double and setBalance(double). The method getCharges() should provide the monthly charge of a contract with all its options selected. The methods getBalance() and setBalance() should be passed through and access the basic contract.",
    "textual_uml": "```\nCLASS: Contract\nDescription: This class represents the basic prepaid cell phone contract. It contains attributes such as contract number and balance, and methods for managing these attributes.\nATTRIBUTES:\n- contractNumber: int\n- balance: double\nMETHODS:\n- getCharges(): double\n- getBalance(): double\n- setBalance(double balance): void\n\nRELATIONSHIPS:\n- Contract Aggregation Option 0..*\n\nCLASS: Option\nDescription: This class represents the various options that can be added to a contract (e.g., data, SMS, minutes, transfer rate). Each option has a monthly charge associated with it.\nATTRIBUTES:\n- monthlyCharge: double\nMETHODS:\n- getMonthlyCharge(): double\n- getCharges(): double\n\nRELATIONSHIPS:\n- Option Inheritance DataOption 1\n- Option Inheritance SmsOption 1\n- Option Inheritance MinutesOption 1\n- Option Inheritance TransferRateOption 1\n\nCLASS: DataOption\nDescription: This class is a specific type of Option that represents the 100 MB of data. It will have its own charge and behavior.\nATTRIBUTES:\n- monthlyCharge: double (set to 1.00€)\nMETHODS:\n- getMonthlyCharge(): double\n- getCharges(): double\n\nRELATIONSHIPS:\n- None\n\nCLASS: SmsOption\nDescription: This class is a specific type of Option that represents the 50 SMS. It will have its own charge and behavior.\nATTRIBUTES:\n- monthlyCharge: double (set to 0.50€)\nMETHODS:\n- getMonthlyCharge(): double\n- getCharges(): double\n\nRELATIONSHIPS:\n- None\n\nCLASS: MinutesOption\nDescription: This class is a specific type of Option that represents the 50 minutes. It will have its own charge and behavior.\nATTRIBUTES:\n- monthlyCharge: double (set to 1.50€)\nMETHODS:\n- getMonthlyCharge(): double\n- getCharges(): double\n\nRELATIONSHIPS:\n- None\n\nCLASS: TransferRateOption\nDescription: This class is a specific type of Option that represents the Double Transfer Rate. It will have its own charge and behavior.\nATTRIBUTES:\n- monthlyCharge: double (set to 2.00€)\nMETHODS:\n- getMonthlyCharge(): double\n- getCharges(): double\n\nRELATIONSHIPS:\n- None\n\nCLASS: Decorator\nDescription: This class serves as a base for the decorator pattern, allowing options to be added to the contract dynamically. It will facilitate the aggregation of charges from the basic contract and any added options.\nATTRIBUTES:\n- contract: Contract\nMETHODS:\n- getCharges(): double\n- getBalance(): double\n- setBalance(double balance): void\n\nRELATIONSHIPS:\n- Decorator Composition Contract 1\n\nCLASS: ChargesCalculator\nDescription: This class is responsible for calculating the total monthly charges of a contract, taking into account the base contract and any options that have been added.\nATTRIBUTES:\n- contract: Contract\nMETHODS:\n- calculateTotalCharges(): double\n\nRELATIONSHIPS:\n- ChargesCalculator Composition Contract 1\n```"
  },
  {
    "title": "Library System",
    "description": "The exercise id to design a class structure for a library system. It should fulfil those requirements: ● There are two type of users – under-aged and adults. ● Under-aged users are identified with usage of their full name and student card. ● Adult users are identified with usage of their full name and ID card. ● The library contains books. ● There is basic information about every book (title, author, etc). ● The user can borrow at most 4 books at the same time. ● There is a history of previously borrowed books for every user (along with all the dates).",
    "textual_uml": "```\nCLASS: User\nDescription: This class represents the general concept of a user in the library system, encompassing both under-aged and adult users with shared attributes.\nATTRIBUTES:\n- fullName: String\n- email: String\n- phoneNumber: String\nMETHODS:\n- getFullName(): String\n- getEmail(): String\n- getPhoneNumber(): String\n- setFullName(name: String): void\n- setEmail(email: String): void\n- setPhoneNumber(phone: String): void\n\nCLASS: UnderAgedUser\nDescription: This class represents users who are under-aged, extending the User class and including specific attributes like student card.\nATTRIBUTES:\n- studentCard: String\n- borrowedBooks: List<Book>\nMETHODS:\n- getStudentCard(): String\n- setStudentCard(card: String): void\n- borrowBook(book: Book): boolean\n- returnBook(book: Book): boolean\n- getBorrowedBooks(): List<Book>\n\nCLASS: AdultUser\nDescription: This class represents adult users, extending the User class and including attributes specific to adult users such as ID card.\nATTRIBUTES:\n- idCard: String\n- borrowedBooks: List<Book>\nMETHODS:\n- getIdCard(): String\n- setIdCard(card: String): void\n- borrowBook(book: Book): boolean\n- returnBook(book: Book): boolean\n- getBorrowedBooks(): List<Book>\n\nCLASS: Book\nDescription: This class represents the books available in the library, containing basic information about each book.\nATTRIBUTES:\n- title: String\n- author: String\n- isbn: String\n- availableCopies: int\nMETHODS:\n- getTitle(): String\n- getAuthor(): String\n- getIsbn(): String\n- getAvailableCopies(): int\n- setAvailableCopies(copies: int): void\n- isAvailable(): boolean\n\nCLASS: Borrowing\nDescription: This class represents the act of borrowing books, including attributes for the user, book, and borrowing dates.\nATTRIBUTES:\n- user: User\n- book: Book\n- borrowingDate: Date\n- returnDate: Date\nMETHODS:\n- getUser(): User\n- getBook(): Book\n- getBorrowingDate(): Date\n- getReturnDate(): Date\n- setReturnDate(date: Date): void\n\nCLASS: BorrowingHistory\nDescription: This class represents the history of previously borrowed books for each user, tracking past transactions.\nATTRIBUTES:\n- user: User\n- borrowings: List<Borrowing>\nMETHODS:\n- getUser(): User\n- getBorrowings(): List<Borrowing>\n- addBorrowing(borrowing: Borrowing): void\n- getBorrowingHistory(): List<Borrowing>\n\nRELATIONSHIPS:\n- User Inheritance UnderAgedUser 1\n- User Inheritance AdultUser 1\n- User Aggregation BorrowingHistory 1\n- User Association Borrowing 0..*\n- Book Association Borrowing 0..*\n- Borrowing Composition User 1\n- Borrowing Composition Book 1\n- BorrowingHistory Aggregation Borrowing 0..*\n```"
  },
  {
    "title": "MyDoctor",
    "description": "The MyDoctor application aims to be a management tool for the appointments of a doctor. A hospital has multiple offices. The users of the application can be doctors and patients. The doctors can apply to practice in offices and create a schedule for an office. The schedules in different offices can’t overlay. 📝 Example: Doctor Ana is available in Office 4 on the 4th of September during 1 PM - 5PM. Doctor Ana can’t practice in Office 5 on the 4th of September during 3PM - 8 PM, but she can practice in Office 5 on the 4th of September during 5:30PM - 8 PM. The patients can see the existing doctors in the system, the schedule of the offices and can book appointments for specific doctors and for specific schedules. The appointments can be of 3 types: ● Blood Test - 15 mins ● Consultation - 30 mins ● Surgery - 60 mins The booking of an appointment will not be possible if another appointment is already booked at the same time frame. An email is sent to the patient with the confirmation of the appointment. 📝 Example: Action 1: User Mike will create a blood test booking for Doctor Ana for the 4th of September starting with 15:30 PM → Possible Action 2: User Mike will create an intervention booking for Doctor Ana for the 4th of September starting with 15:00 PM → Not Possible Action 3: User Mike will create an intervention booking for Doctor Ana for the 4th of September starting with 16:00 PM → Possible",
    "textual_uml": "```plaintext\nCLASS: Hospital\nDescription: Represents the overarching entity that contains multiple offices where doctors practice.\nATTRIBUTES:\n- name: String\n- location: String\n- offices: List<Office>\nMETHODS:\n- addOffice(office: Office): void\n- removeOffice(office: Office): void\n- getOffices(): List<Office>\n\nRELATIONSHIPS:\n- Hospital aggregation Office 1..*\n\nCLASS: Office\nDescription: Represents individual locations within a hospital where doctors can see patients and manage their schedules.\nATTRIBUTES:\n- name: String\n- location: String\n- hospital: Hospital\n- doctors: List<Doctor>\n- schedules: List<Schedule>\nMETHODS:\n- addDoctor(doctor: Doctor): void\n- removeDoctor(doctor: Doctor): void\n- createSchedule(schedule: Schedule): void\n- getSchedules(): List<Schedule>\n\nRELATIONSHIPS:\n- Office aggregation Doctor 0..*\n- Office aggregation Schedule 0..*\n- Office association Doctor 0..*\n\nCLASS: Doctor\nDescription: Represents the medical professionals who can create schedules, practice in offices, and have appointments with patients.\nATTRIBUTES:\n- name: String\n- specialization: String\n- offices: List<Office>\n- schedules: List<Schedule>\nMETHODS:\n- addOffice(office: Office): void\n- removeOffice(office: Office): void\n- createSchedule(schedule: Schedule): void\n- getAvailableSchedules(): List<Schedule>\n\nRELATIONSHIPS:\n- Doctor association Schedule 0..*\n- Doctor association Office 0..*\n\nCLASS: Patient\nDescription: Represents the users of the application who can view doctors, schedules, and book appointments.\nATTRIBUTES:\n- name: String\n- email: String\n- appointments: List<Appointment>\nMETHODS:\n- bookAppointment(appointment: Appointment): void\n- cancelAppointment(appointment: Appointment): void\n- getAppointments(): List<Appointment>\n\nRELATIONSHIPS:\n- Patient association Appointment 0..*\n\nCLASS: Schedule\nDescription: Represents the time slots available for doctors in specific offices, indicating when they are available for appointments.\nATTRIBUTES:\n- date: Date\n- startTime: Time\n- endTime: Time\n- doctor: Doctor\n- office: Office\n- appointments: List<Appointment>\nMETHODS:\n- addAppointment(appointment: Appointment): void\n- removeAppointment(appointment: Appointment): void\n- isAvailable(time: Time, duration: int): boolean\n\nRELATIONSHIPS:\n- Schedule association Appointment 0..*\n- Schedule association Doctor 0..*\n- Schedule aggregation Office 0..*\n\nCLASS: Appointment\nDescription: Represents the actual bookings made by patients with doctors, which can be of different types (Blood Test, Consultation, Surgery).\nATTRIBUTES:\n- patient: Patient\n- doctor: Doctor\n- schedule: Schedule\n- appointmentType: AppointmentType\n- dateTime: DateTime\nMETHODS:\n- confirm(): void\n- cancel(): void\n- getDetails(): String\n\nRELATIONSHIPS:\n- Appointment association Doctor 1\n- Appointment association Schedule 1\n- Appointment association Appointment Type 1\n- Appointment association Email 0..*\n\nCLASS: Email\nDescription: Represents the communication sent to patients for appointment confirmations, indicating a notification mechanism within the application.\nATTRIBUTES:\n- recipient: String\n- subject: String\n- body: String\n- sentDate: DateTime\nMETHODS:\n- send(): void\n- getDetails(): String\n\nRELATIONSHIPS:\n- Email association Appointment 0..1\n\nCLASS: Appointment Type\nDescription: Represents the different categories of appointments (Blood Test, Consultation, Surgery) that have specific durations and characteristics.\nATTRIBUTES:\n- name: String\n- duration: int\nMETHODS:\n- getDuration(): int\n- getName(): String\n\nRELATIONSHIPS:\n- Appointment Type association Appointment 1\n```"
  },
  {
    "title": "Online Shopping",
    "description": "Each customer has unique id and is linked to exactly one account. Account owns shopping cart and orders. Customer could register as a web user to be able to buy items online. Customer is not required to be a web user because purchases could also be made by phone or by ordering from catalogues. Web user has login name which also serves as unique id. Web user could be in several states - new, active, temporary blocked, or banned, and be linked to a shopping cart. Shopping cart belongs to account. Account owns customer orders. Customer may have no orders. Customer orders are sorted and unique. Each order could refer to several payments, possibly none. Every payment has unique id and is related to exactly one account. Each order has current order status. Both order and shopping cart have line items linked to a specific product. Each line item is related to exactly one product. A product could be associated to many line items or no item at all.",
    "textual_uml": "```plaintext\nCLASS: Customer\nDescription: Represents individuals who make purchases. Each customer has a unique ID and is linked to an account.\nATTRIBUTES:\n- customerId: String\n- account: Account\n- webUser: WebUser\nMETHODS:\n- getCustomerId(): String\n- getAccount(): Account\n- registerWebUser(webUser: WebUser): void\n\nRELATIONSHIPS:\n- Customer association Account 1\n- Customer association WebUser 0..1\n\nCLASS: Account\nDescription: Represents a financial or transactional entity that owns a shopping cart and customer orders. It links customers to their purchases.\nATTRIBUTES:\n- accountId: String\n- customer: Customer\n- shoppingCart: ShoppingCart\n- orders: List<Order>\nMETHODS:\n- getAccountId(): String\n- getCustomer(): Customer\n- getShoppingCart(): ShoppingCart\n- getOrders(): List<Order>\n- addOrder(order: Order): void\n\nRELATIONSHIPS:\n- Account aggregation ShoppingCart 1\n- Account aggregation Order 0..*\n\nCLASS: ShoppingCart\nDescription: Represents a temporary storage for items that a customer intends to purchase. It is linked to an account and contains line items.\nATTRIBUTES:\n- cartId: String\n- account: Account\n- lineItems: List<LineItem>\nMETHODS:\n- getCartId(): String\n- getAccount(): Account\n- getLineItems(): List<LineItem>\n- addLineItem(lineItem: LineItem): void\n- removeLineItem(lineItem: LineItem): void\n\nRELATIONSHIPS:\n- ShoppingCart composition LineItem 0..*\n\nCLASS: Order\nDescription: Represents a completed transaction that may consist of multiple payments. Each order is linked to an account and has a current status.\nATTRIBUTES:\n- orderId: String\n- account: Account\n- lineItems: List<LineItem>\n- status: OrderStatus\n- payments: List<Payment>\nMETHODS:\n- getOrderId(): String\n- getAccount(): Account\n- getLineItems(): List<LineItem>\n- getStatus(): OrderStatus\n- addPayment(payment: Payment): void\n\nRELATIONSHIPS:\n- Order composition LineItem 0..*\n- Order aggregation Payment 0..*\n- Order association OrderStatus 1\n\nCLASS: Payment\nDescription: Represents a financial transaction related to an order. Each payment has a unique ID and is associated with an account.\nATTRIBUTES:\n- paymentId: String\n- order: Order\n- account: Account\n- amount: Double\n- paymentDate: Date\nMETHODS:\n- getPaymentId(): String\n- getOrder(): Order\n- getAccount(): Account\n- getAmount(): Double\n- getPaymentDate(): Date\n\nRELATIONSHIPS:\n- Payment association Account 1\n\nCLASS: WebUser\nDescription: Represents customers who register to buy items online. It has a unique login name and can have various states (new, active, etc.).\nATTRIBUTES:\n- loginName: String\n- customer: Customer\n- state: String\nMETHODS:\n- getLoginName(): String\n- getCustomer(): Customer\n- getState(): String\n- setState(state: String): void\n\nRELATIONSHIPS:\n- WebUser association ShoppingCart 0..1\n\nCLASS: LineItem\nDescription: Represents individual items within a shopping cart or order. Each line item is linked to a specific product.\nATTRIBUTES:\n- lineItemId: String\n- product: Product\n- quantity: Integer\n- price: Double\nMETHODS:\n- getLineItemId(): String\n- getProduct(): Product\n- getQuantity(): Integer\n- getPrice(): Double\n\nRELATIONSHIPS:\n- LineItem association Product 1\n\nCLASS: Product\nDescription: Represents items available for purchase. A product can be associated with multiple line items or none at all.\nATTRIBUTES:\n- productId: String\n- name: String\n- description: String\n- price: Double\n- lineItems: List<LineItem>\nMETHODS:\n- getProductId(): String\n- getName(): String\n- getDescription(): String\n- getPrice(): Double\n- getLineItems(): List<LineItem>\n\nCLASS: OrderStatus\nDescription: Represents the current state of an order (e.g., pending, completed, canceled). This is important for tracking the order's progress.\nATTRIBUTES:\n- statusId: String\n- statusName: String\nMETHODS:\n- getStatusId(): String\n- getStatusName(): String\n```"
  }
]